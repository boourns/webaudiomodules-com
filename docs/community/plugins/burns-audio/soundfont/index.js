/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompositeAudioNode\": () => (/* binding */ CompositeAudioNode),\n/* harmony export */   \"ParamMgrFactory\": () => (/* binding */ ParamMgrFactory)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/CompositeAudioNode.js\nvar CompositeAudioNode = class extends GainNode {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"_output\");\n    __publicField(this, \"_wamNode\");\n  }\n  get groupId() {\n    return this._wamNode.groupId;\n  }\n  get moduleId() {\n    return this._wamNode.moduleId;\n  }\n  get instanceId() {\n    return this._wamNode.instanceId;\n  }\n  get module() {\n    return this._wamNode.module;\n  }\n  addEventListener(...args) {\n    return this._wamNode.addEventListener(...args);\n  }\n  removeEventListener(...args) {\n    return this._wamNode.removeEventListener(...args);\n  }\n  dispatchEvent(...args) {\n    return this._wamNode.dispatchEvent(...args);\n  }\n  getParameterInfo(...args) {\n    return this._wamNode.getParameterInfo(...args);\n  }\n  getParameterValues(...args) {\n    return this._wamNode.getParameterValues(...args);\n  }\n  setParameterValues(...args) {\n    return this._wamNode.setParameterValues(...args);\n  }\n  getState() {\n    return this._wamNode.getState();\n  }\n  setState(...args) {\n    return this._wamNode.setState(...args);\n  }\n  getCompensationDelay() {\n    return this._wamNode.getCompensationDelay();\n  }\n  scheduleEvents(...args) {\n    return this._wamNode.scheduleEvents(...args);\n  }\n  clearEvents() {\n    return this._wamNode.clearEvents();\n  }\n  connectEvents(...args) {\n    return this._wamNode.connectEvents(...args);\n  }\n  disconnectEvents(...args) {\n    return this._wamNode.disconnectEvents(...args);\n  }\n  destroy() {\n    return this._wamNode.destroy();\n  }\n  set channelCount(count) {\n    if (this._output)\n      this._output.channelCount = count;\n    else\n      super.channelCount = count;\n  }\n  get channelCount() {\n    if (this._output)\n      return this._output.channelCount;\n    return super.channelCount;\n  }\n  set channelCountMode(mode) {\n    if (this._output)\n      this._output.channelCountMode = mode;\n    else\n      super.channelCountMode = mode;\n  }\n  get channelCountMode() {\n    if (this._output)\n      return this._output.channelCountMode;\n    return super.channelCountMode;\n  }\n  set channelInterpretation(interpretation) {\n    if (this._output)\n      this._output.channelInterpretation = interpretation;\n    else\n      super.channelInterpretation = interpretation;\n  }\n  get channelInterpretation() {\n    if (this._output)\n      return this._output.channelInterpretation;\n    return super.channelInterpretation;\n  }\n  get numberOfInputs() {\n    return super.numberOfInputs;\n  }\n  get numberOfOutputs() {\n    if (this._output)\n      return this._output.numberOfOutputs;\n    return super.numberOfOutputs;\n  }\n  get gain() {\n    return void 0;\n  }\n  connect(...args) {\n    if (this._output && this._output !== this)\n      return this._output.connect(...args);\n    return super.connect(...args);\n  }\n  disconnect(...args) {\n    if (this._output && this._output !== this)\n      return this._output.disconnect(...args);\n    return super.disconnect(...args);\n  }\n};\n\n// src/sdk/src/addFunctionModule.js\nvar addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\n  const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(\", \")});`;\n  const url = URL.createObjectURL(new Blob([text], { type: \"text/javascript\" }));\n  return audioWorklet.addModule(url);\n};\nvar addFunctionModule_default = addFunctionModule;\n\n// src/ParamMgrProcessor.js\nvar processor = (moduleId, paramsConfig) => {\n  const audioWorkletGlobalScope = globalThis;\n  const {\n    AudioWorkletProcessor,\n    registerProcessor,\n    webAudioModules\n  } = audioWorkletGlobalScope;\n  const supportSharedArrayBuffer = !!globalThis.SharedArrayBuffer;\n  const SharedArrayBuffer = globalThis.SharedArrayBuffer || globalThis.ArrayBuffer;\n  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n  const normalizeE = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n  const normalize = (x, min, max) => min === 0 && max === 1 ? x : (x - min) / (max - min) || 0;\n  const denormalize = (x, min, max) => min === 0 && max === 1 ? x : x * (max - min) + min;\n  const mapValue = (x, eMin, eMax, sMin, sMax, tMin, tMax) => denormalize(normalize(normalize(Math.min(sMax, Math.max(sMin, x)), eMin, eMax), normalize(sMin, eMin, eMax), normalize(sMax, eMin, eMax)), tMin, tMax);\n  class ParamMgrProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return Object.entries(paramsConfig).map(([name, { defaultValue, minValue, maxValue }]) => ({\n        name,\n        defaultValue,\n        minValue,\n        maxValue\n      }));\n    }\n    constructor(options) {\n      super(options);\n      this.destroyed = false;\n      this.supportSharedArrayBuffer = supportSharedArrayBuffer;\n      const {\n        paramsMapping,\n        internalParamsMinValues,\n        internalParams,\n        groupId,\n        instanceId\n      } = options.processorOptions;\n      this.groupId = groupId;\n      this.moduleId = moduleId;\n      this.instanceId = instanceId;\n      this.internalParamsMinValues = internalParamsMinValues;\n      this.paramsConfig = paramsConfig;\n      this.paramsMapping = paramsMapping;\n      this.paramsValues = {};\n      Object.entries(paramsConfig).forEach(([name, { defaultValue }]) => {\n        this.paramsValues[name] = defaultValue;\n      });\n      this.internalParams = internalParams;\n      this.internalParamsCount = this.internalParams.length;\n      this.buffer = new SharedArrayBuffer((this.internalParamsCount + 1) * Float32Array.BYTES_PER_ELEMENT);\n      this.$lock = new Int32Array(this.buffer, 0, 1);\n      this.$internalParamsBuffer = new Float32Array(this.buffer, 4, this.internalParamsCount);\n      this.eventQueue = [];\n      this.handleEvent = null;\n      audioWorkletGlobalScope.webAudioModules.addWam(this);\n      this.messagePortRequestId = -1;\n      const resolves = {};\n      const rejects = {};\n      this.call = (call, ...args) => new Promise((resolve, reject) => {\n        const id = this.messagePortRequestId--;\n        resolves[id] = resolve;\n        rejects[id] = reject;\n        this.port.postMessage({ id, call, args });\n      });\n      this.handleMessage = ({ data }) => {\n        const { id, call, args, value, error } = data;\n        if (call) {\n          const r = { id };\n          try {\n            r.value = this[call](...args);\n          } catch (e) {\n            r.error = e;\n          }\n          this.port.postMessage(r);\n        } else {\n          if (error) {\n            if (rejects[id])\n              rejects[id](error);\n            delete rejects[id];\n            return;\n          }\n          if (resolves[id]) {\n            resolves[id](value);\n            delete resolves[id];\n          }\n        }\n      };\n      this.port.start();\n      this.port.addEventListener(\"message\", this.handleMessage);\n    }\n    setParamsMapping(mapping) {\n      this.paramsMapping = mapping;\n    }\n    getBuffer() {\n      return { lock: this.$lock, paramsBuffer: this.$internalParamsBuffer };\n    }\n    getCompensationDelay() {\n      return 128;\n    }\n    getParameterInfo(...parameterIdQuery) {\n      if (parameterIdQuery.length === 0)\n        parameterIdQuery = Object.keys(this.paramsConfig);\n      const parameterInfo = {};\n      parameterIdQuery.forEach((parameterId) => {\n        parameterInfo[parameterId] = this.paramsConfig[parameterId];\n      });\n      return parameterInfo;\n    }\n    getParameterValues(normalized, ...parameterIdQuery) {\n      if (parameterIdQuery.length === 0)\n        parameterIdQuery = Object.keys(this.paramsConfig);\n      const parameterValues = {};\n      parameterIdQuery.forEach((parameterId) => {\n        if (!(parameterId in this.paramsValues))\n          return;\n        const { minValue, maxValue, exponent } = this.paramsConfig[parameterId];\n        const value = this.paramsValues[parameterId];\n        parameterValues[parameterId] = {\n          id: parameterId,\n          value: normalized ? normalizeE(value, minValue, maxValue, exponent) : value,\n          normalized\n        };\n      });\n      return parameterValues;\n    }\n    scheduleEvents(...events) {\n      this.eventQueue.push(...events);\n      const { currentTime } = audioWorkletGlobalScope;\n      this.eventQueue.sort((a, b) => (a.time || currentTime) - (b.time || currentTime));\n    }\n    emitEvents(...events) {\n      webAudioModules.emitEvents(this, ...events);\n    }\n    clearEvents() {\n      this.eventQueue = [];\n    }\n    lock() {\n      if (globalThis.Atomics)\n        Atomics.store(this.$lock, 0, 1);\n    }\n    unlock() {\n      if (globalThis.Atomics)\n        Atomics.store(this.$lock, 0, 0);\n    }\n    process(inputs, outputs, parameters) {\n      if (this.destroyed)\n        return false;\n      const outputOffset = 1;\n      this.lock();\n      Object.entries(this.paramsConfig).forEach(([name, { minValue, maxValue }]) => {\n        const raw = parameters[name];\n        if (name in this.paramsValues)\n          this.paramsValues[name] = raw[raw.length - 1];\n        if (!this.paramsMapping[name])\n          return;\n        Object.entries(this.paramsMapping[name]).forEach(([targetName, targetMapping]) => {\n          const j = this.internalParams.indexOf(targetName);\n          if (j === -1)\n            return;\n          const intrinsicValue = this.internalParamsMinValues[j];\n          const { sourceRange, targetRange } = targetMapping;\n          const [sMin, sMax] = sourceRange;\n          const [tMin, tMax] = targetRange;\n          let out;\n          if (minValue !== tMin || maxValue !== tMax || minValue !== sMin || maxValue !== sMax) {\n            out = raw.map((v) => {\n              const mappedValue = mapValue(v, minValue, maxValue, sMin, sMax, tMin, tMax);\n              return mappedValue - intrinsicValue;\n            });\n          } else if (intrinsicValue) {\n            out = raw.map((v) => v - intrinsicValue);\n          } else {\n            out = raw;\n          }\n          if (out.length === 1)\n            outputs[j + outputOffset][0].fill(out[0]);\n          else\n            outputs[j + outputOffset][0].set(out);\n          this.$internalParamsBuffer[j] = out[0];\n        });\n      });\n      this.unlock();\n      if (!this.supportSharedArrayBuffer) {\n        this.call(\"setBuffer\", { lock: this.$lock, paramsBuffer: this.$internalParamsBuffer });\n      }\n      const { currentTime } = audioWorkletGlobalScope;\n      let $event;\n      for ($event = 0; $event < this.eventQueue.length; $event++) {\n        const event = this.eventQueue[$event];\n        if (event.time && event.time > currentTime)\n          break;\n        if (typeof this.handleEvent === \"function\")\n          this.handleEvent(event);\n        this.call(\"dispatchWamEvent\", event);\n      }\n      if ($event)\n        this.eventQueue.splice(0, $event);\n      return true;\n    }\n    connectEvents(wamInstanceId, output) {\n      webAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    disconnectEvents(wamInstanceId, output) {\n      if (typeof wamInstanceId === \"undefined\") {\n        webAudioModules.disconnectEvents(this.groupId, this.instanceId);\n        return;\n      }\n      webAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    destroy() {\n      audioWorkletGlobalScope.webAudioModules.removeWam(this);\n      this.destroyed = true;\n      this.port.close();\n    }\n  }\n  try {\n    registerProcessor(moduleId, ParamMgrProcessor);\n  } catch (error) {\n    console.warn(error);\n  }\n};\nvar ParamMgrProcessor_default = processor;\n\n// src/sdk/src/WamParameterInfo.js\nvar getWamParameterInfo = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n  const denormExp = (x, e) => e === 0 ? x : x ** 1.5 ** e;\n  const normalize = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n  const denormalize = (x, min, max, e = 0) => min === 0 && max === 1 ? denormExp(x, e) : denormExp(x, e) * (max - min) + min;\n  const inRange = (x, min, max) => x >= min && x <= max;\n  class WamParameterInfo2 {\n    constructor(id, config = {}) {\n      let {\n        type,\n        label,\n        defaultValue,\n        minValue,\n        maxValue,\n        discreteStep,\n        exponent,\n        choices,\n        units\n      } = config;\n      if (type === void 0)\n        type = \"float\";\n      if (label === void 0)\n        label = \"\";\n      if (defaultValue === void 0)\n        defaultValue = 0;\n      if (choices === void 0)\n        choices = [];\n      if (type === \"boolean\" || type === \"choice\") {\n        discreteStep = 1;\n        minValue = 0;\n        if (choices.length)\n          maxValue = choices.length - 1;\n        else\n          maxValue = 1;\n      } else {\n        if (minValue === void 0)\n          minValue = 0;\n        if (maxValue === void 0)\n          maxValue = 1;\n        if (discreteStep === void 0)\n          discreteStep = 0;\n        if (exponent === void 0)\n          exponent = 0;\n        if (units === void 0)\n          units = \"\";\n      }\n      const errBase = `Param config error | ${id}: `;\n      if (minValue >= maxValue)\n        throw Error(errBase.concat(\"minValue must be less than maxValue\"));\n      if (!inRange(defaultValue, minValue, maxValue))\n        throw Error(errBase.concat(\"defaultValue out of range\"));\n      if (discreteStep % 1 || discreteStep < 0) {\n        throw Error(errBase.concat(\"discreteStep must be a non-negative integer\"));\n      } else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n        throw Error(errBase.concat(\"non-zero discreteStep requires integer minValue, maxValue, and defaultValue\"));\n      }\n      if (type === \"choice\" && !choices.length) {\n        throw Error(errBase.concat(\"choice type parameter requires list of strings in choices\"));\n      }\n      this.id = id;\n      this.label = label;\n      this.type = type;\n      this.defaultValue = defaultValue;\n      this.minValue = minValue;\n      this.maxValue = maxValue;\n      this.discreteStep = discreteStep;\n      this.exponent = exponent;\n      this.choices = choices;\n      this.units = units;\n    }\n    normalize(value) {\n      return normalize(value, this.minValue, this.maxValue, this.exponent);\n    }\n    denormalize(valueNorm) {\n      return denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n    }\n    valueString(value) {\n      if (this.choices)\n        return this.choices[value];\n      if (this.units !== \"\")\n        return `${value} ${this.units}`;\n      return `${value}`;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameterInfo)\n      ModuleScope.WamParameterInfo = WamParameterInfo2;\n  }\n  return WamParameterInfo2;\n};\nvar WamParameterInfo_default = getWamParameterInfo;\n\n// src/ParamConfigurator.js\nvar WamParameterInfo = WamParameterInfo_default();\nvar ParamMappingConfigurator = class {\n  constructor(options = {}) {\n    __publicField(this, \"_paramsConfig\");\n    __publicField(this, \"_internalParamsConfig\");\n    __publicField(this, \"_paramsMapping\", {});\n    const { paramsConfig, paramsMapping, internalParamsConfig } = options;\n    this._paramsConfig = paramsConfig;\n    this._paramsMapping = paramsMapping;\n    this._internalParamsConfig = internalParamsConfig;\n  }\n  get paramsConfig() {\n    const { internalParamsConfig } = this;\n    return Object.entries(this._paramsConfig || internalParamsConfig).reduce((configs, [id, config]) => {\n      var _a, _b, _c, _d;\n      const internalParam = internalParamsConfig[id];\n      configs[id] = new WamParameterInfo(id, __spreadProps(__spreadValues({}, config), {\n        label: (_a = config.label) != null ? _a : id,\n        defaultValue: (_b = config.defaultValue) != null ? _b : internalParam == null ? void 0 : internalParam.defaultValue,\n        minValue: (_c = config.minValue) != null ? _c : internalParam == null ? void 0 : internalParam.minValue,\n        maxValue: (_d = config.maxValue) != null ? _d : internalParam == null ? void 0 : internalParam.maxValue\n      }));\n      return configs;\n    }, {});\n  }\n  get internalParamsConfig() {\n    return Object.entries(this._internalParamsConfig || {}).reduce((configs, [name, config]) => {\n      if (config instanceof AudioParam)\n        configs[name] = config;\n      else {\n        const defaultConfig = {\n          minValue: 0,\n          maxValue: 1,\n          defaultValue: 0,\n          automationRate: 30\n        };\n        configs[name] = __spreadValues(__spreadValues({}, defaultConfig), config);\n      }\n      return configs;\n    }, {});\n  }\n  get paramsMapping() {\n    const declared = this._paramsMapping || {};\n    const externalParams = this.paramsConfig;\n    const internalParams = this.internalParamsConfig;\n    return Object.entries(externalParams).reduce((mapping, [name, { minValue, maxValue }]) => {\n      const sourceRange = [minValue, maxValue];\n      const defaultMapping = { sourceRange, targetRange: [...sourceRange] };\n      if (declared[name]) {\n        const declaredTargets = Object.entries(declared[name]).reduce((targets, [targetName, targetMapping]) => {\n          if (internalParams[targetName]) {\n            targets[targetName] = __spreadValues(__spreadValues({}, defaultMapping), targetMapping);\n          }\n          return targets;\n        }, {});\n        mapping[name] = declaredTargets;\n      } else if (internalParams[name]) {\n        mapping[name] = { [name]: __spreadValues({}, defaultMapping) };\n      }\n      return mapping;\n    }, {});\n  }\n};\n\n// src/MgrAudioParam.js\nvar MgrAudioParam = class extends AudioParam {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"_info\");\n  }\n  get exponent() {\n    return this.info.exponent;\n  }\n  get info() {\n    return this._info;\n  }\n  set info(info) {\n    this._info = info;\n  }\n  set normalizedValue(valueIn) {\n    this.value = this.info.denormalize(valueIn);\n  }\n  get normalizedValue() {\n    return this.info.normalize(this.value);\n  }\n  setValueAtTime(value, startTime) {\n    return super.setValueAtTime(value, startTime);\n  }\n  setNormalizedValueAtTime(valueIn, startTime) {\n    const value = this.info.denormalize(valueIn);\n    return this.setValueAtTime(value, startTime);\n  }\n  linearRampToValueAtTime(value, endTime) {\n    return super.linearRampToValueAtTime(value, endTime);\n  }\n  linearRampToNormalizedValueAtTime(valueIn, endTime) {\n    const value = this.info.denormalize(valueIn);\n    return this.linearRampToValueAtTime(value, endTime);\n  }\n  exponentialRampToValueAtTime(value, endTime) {\n    return super.exponentialRampToValueAtTime(value, endTime);\n  }\n  exponentialRampToNormalizedValueAtTime(valueIn, endTime) {\n    const value = this.info.denormalize(valueIn);\n    return this.exponentialRampToValueAtTime(value, endTime);\n  }\n  setTargetAtTime(target, startTime, timeConstant) {\n    return super.setTargetAtTime(target, startTime, timeConstant);\n  }\n  setNormalizedTargetAtTime(targetIn, startTime, timeConstant) {\n    const target = this.info.denormalize(targetIn);\n    return this.setTargetAtTime(target, startTime, timeConstant);\n  }\n  setValueCurveAtTime(values, startTime, duration) {\n    return super.setValueCurveAtTime(values, startTime, duration);\n  }\n  setNormalizedValueCurveAtTime(valuesIn, startTime, duration) {\n    const values = Array.from(valuesIn).map((v) => this.info.denormalize(v));\n    return this.setValueCurveAtTime(values, startTime, duration);\n  }\n  cancelScheduledParamValues(cancelTime) {\n    return super.cancelScheduledValues(cancelTime);\n  }\n  cancelAndHoldParamAtTime(cancelTime) {\n    return super.cancelAndHoldAtTime(cancelTime);\n  }\n};\n\n// src/ParamMgrNode.js\nvar AudioWorkletNode = globalThis.AudioWorkletNode;\nvar ParamMgrNode = class extends AudioWorkletNode {\n  constructor(module, options) {\n    super(module.audioContext, module.moduleId, {\n      numberOfInputs: 0,\n      numberOfOutputs: 1 + options.processorOptions.internalParams.length,\n      parameterData: options.parameterData,\n      processorOptions: options.processorOptions\n    });\n    __publicField(this, \"requestDispatchIParamChange\", (name) => {\n      const config = this.internalParamsConfig[name];\n      if (!(\"onChange\" in config))\n        return;\n      const { automationRate, onChange } = config;\n      if (typeof automationRate !== \"number\" || !automationRate)\n        return;\n      const interval = 1e3 / automationRate;\n      const i = this.internalParams.indexOf(name);\n      if (i === -1)\n        return;\n      if (i >= this.internalParams.length)\n        return;\n      if (typeof this.paramsUpdateCheckFnRef[i] === \"number\") {\n        window.clearTimeout(this.paramsUpdateCheckFnRef[i]);\n      }\n      this.paramsUpdateCheckFn[i] = () => {\n        const prev = this.$prevParamsBuffer[i];\n        const cur = this.$paramsBuffer[i];\n        if (cur !== prev) {\n          onChange(cur, prev);\n          this.$prevParamsBuffer[i] = cur;\n        }\n        this.paramsUpdateCheckFnRef[i] = window.setTimeout(this.paramsUpdateCheckFn[i], interval);\n      };\n      this.paramsUpdateCheckFn[i]();\n    });\n    const { processorOptions, internalParamsConfig } = options;\n    this.initialized = false;\n    this.module = module;\n    this.paramsConfig = processorOptions.paramsConfig;\n    this.internalParams = processorOptions.internalParams;\n    this.internalParamsConfig = internalParamsConfig;\n    this.$prevParamsBuffer = new Float32Array(this.internalParams.length);\n    this.paramsUpdateCheckFn = [];\n    this.paramsUpdateCheckFnRef = [];\n    this.messageRequestId = 0;\n    Object.entries(this.getParams()).forEach(([name, param]) => {\n      Object.setPrototypeOf(param, MgrAudioParam.prototype);\n      param._info = this.paramsConfig[name];\n    });\n    const resolves = {};\n    const rejects = {};\n    this.call = (call, ...args) => {\n      const id = this.messageRequestId;\n      this.messageRequestId += 1;\n      return new Promise((resolve, reject) => {\n        resolves[id] = resolve;\n        rejects[id] = reject;\n        this.port.postMessage({ id, call, args });\n      });\n    };\n    this.handleMessage = ({ data }) => {\n      const { id, call, args, value, error } = data;\n      if (call) {\n        const r = { id };\n        try {\n          r.value = this[call](...args);\n        } catch (e) {\n          r.error = e;\n        }\n        this.port.postMessage(r);\n      } else {\n        if (error) {\n          if (rejects[id])\n            rejects[id](error);\n          delete rejects[id];\n          return;\n        }\n        if (resolves[id]) {\n          resolves[id](value);\n          delete resolves[id];\n        }\n      }\n    };\n    this.port.start();\n    this.port.addEventListener(\"message\", this.handleMessage);\n  }\n  get parameters() {\n    return super.parameters;\n  }\n  get groupId() {\n    return this.module.groupId;\n  }\n  get moduleId() {\n    return this.module.moduleId;\n  }\n  get instanceId() {\n    return this.module.instanceId;\n  }\n  async initialize() {\n    const response = await this.call(\"getBuffer\");\n    const { lock, paramsBuffer } = response;\n    this.$lock = lock;\n    this.$paramsBuffer = paramsBuffer;\n    const offset = 1;\n    Object.entries(this.internalParamsConfig).forEach(([name, config], i) => {\n      if (this.context.state === \"suspended\")\n        this.$paramsBuffer[i] = config.defaultValue;\n      if (config instanceof AudioParam) {\n        try {\n          config.automationRate = \"a-rate\";\n        } catch (e) {\n        } finally {\n          config.value = Math.max(0, config.minValue);\n          this.connect(config, offset + i);\n        }\n      } else if (config instanceof AudioNode) {\n        this.connect(config, offset + i);\n      } else {\n        this.requestDispatchIParamChange(name);\n      }\n    });\n    this.connect(this.module.audioContext.destination, 0, 0);\n    this.initialized = true;\n    return this;\n  }\n  setBuffer({ lock, paramsBuffer }) {\n    this.$lock = lock;\n    this.$paramsBuffer = paramsBuffer;\n  }\n  setParamsMapping(paramsMapping) {\n    return this.call(\"setParamsMapping\", paramsMapping);\n  }\n  getCompensationDelay() {\n    return this.call(\"getCompensationDelay\");\n  }\n  getParameterInfo(...parameterIdQuery) {\n    return this.call(\"getParameterInfo\", ...parameterIdQuery);\n  }\n  getParameterValues(normalized, ...parameterIdQuery) {\n    return this.call(\"getParameterValues\", normalized, ...parameterIdQuery);\n  }\n  scheduleAutomation(event) {\n    const time = event.time || this.context.currentTime;\n    const { id, normalized, value } = event.data;\n    const audioParam = this.getParam(id);\n    if (!audioParam)\n      return;\n    if (audioParam.info.type === \"float\") {\n      if (normalized)\n        audioParam.linearRampToNormalizedValueAtTime(value, time);\n      else\n        audioParam.linearRampToValueAtTime(value, time);\n    } else {\n      if (normalized)\n        audioParam.setNormalizedValueAtTime(value, time);\n      else\n        audioParam.setValueAtTime(value, time);\n    }\n  }\n  scheduleEvents(...events) {\n    events.forEach((event) => {\n      if (event.type === \"wam-automation\") {\n        this.scheduleAutomation(event);\n      }\n    });\n    this.call(\"scheduleEvents\", ...events);\n  }\n  emitEvents(...events) {\n    this.call(\"emitEvents\", ...events);\n  }\n  clearEvents() {\n    this.call(\"clearEvents\");\n  }\n  dispatchWamEvent(event) {\n    if (event.type === \"wam-automation\") {\n      this.scheduleAutomation(event);\n    } else {\n      this.dispatchEvent(new CustomEvent(event.type, { detail: event }));\n    }\n  }\n  async setParameterValues(parameterValues) {\n    Object.keys(parameterValues).forEach((parameterId) => {\n      const parameterUpdate = parameterValues[parameterId];\n      const parameter = this.parameters.get(parameterId);\n      if (!parameter)\n        return;\n      if (!parameterUpdate.normalized)\n        parameter.value = parameterUpdate.value;\n      else\n        parameter.normalizedValue = parameterUpdate.value;\n    });\n  }\n  async getState() {\n    return this.getParamsValues();\n  }\n  async setState(state) {\n    this.setParamsValues(state);\n  }\n  convertTimeToFrame(time) {\n    return Math.round(time * this.context.sampleRate);\n  }\n  convertFrameToTime(frame) {\n    return frame / this.context.sampleRate;\n  }\n  getIParamIndex(name) {\n    const i = this.internalParams.indexOf(name);\n    return i === -1 ? null : i;\n  }\n  connectIParam(name, dest, index) {\n    const offset = 1;\n    const i = this.getIParamIndex(name);\n    if (i !== null) {\n      if (dest instanceof AudioNode) {\n        if (typeof index === \"number\")\n          this.connect(dest, offset + i, index);\n        else\n          this.connect(dest, offset + i);\n      } else {\n        this.connect(dest, offset + i);\n      }\n    }\n  }\n  disconnectIParam(name, dest, index) {\n    const offset = 1;\n    const i = this.getIParamIndex(name);\n    if (i !== null) {\n      if (dest instanceof AudioNode) {\n        if (typeof index === \"number\")\n          this.disconnect(dest, offset + i, index);\n        else\n          this.disconnect(dest, offset + i);\n      } else {\n        this.disconnect(dest, offset + i);\n      }\n    }\n  }\n  getIParamValue(name) {\n    const i = this.getIParamIndex(name);\n    return i !== null ? this.$paramsBuffer[i] : null;\n  }\n  getIParamsValues() {\n    const values = {};\n    this.internalParams.forEach((name, i) => {\n      values[name] = this.$paramsBuffer[i];\n    });\n    return values;\n  }\n  getParam(name) {\n    return this.parameters.get(name) || null;\n  }\n  getParams() {\n    return Object.fromEntries(this.parameters);\n  }\n  getParamValue(name) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.value;\n  }\n  setParamValue(name, value) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return;\n    param.value = value;\n  }\n  getParamsValues() {\n    const values = {};\n    this.parameters.forEach((v, k) => {\n      values[k] = v.value;\n    });\n    return values;\n  }\n  setParamsValues(values) {\n    if (!values)\n      return;\n    Object.entries(values).forEach(([k, v]) => {\n      this.setParamValue(k, v);\n    });\n  }\n  getNormalizedParamValue(name) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.normalizedValue;\n  }\n  setNormalizedParamValue(name, value) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return;\n    param.normalizedValue = value;\n  }\n  getNormalizedParamsValues() {\n    const values = {};\n    this.parameters.forEach((v, k) => {\n      values[k] = this.getNormalizedParamValue(k);\n    });\n    return values;\n  }\n  setNormalizedParamsValues(values) {\n    if (!values)\n      return;\n    Object.entries(values).forEach(([k, v]) => {\n      this.setNormalizedParamValue(k, v);\n    });\n  }\n  setParamValueAtTime(name, value, startTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setValueAtTime(value, startTime);\n  }\n  setNormalizedParamValueAtTime(name, value, startTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setNormalizedValueAtTime(value, startTime);\n  }\n  linearRampToParamValueAtTime(name, value, endTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.linearRampToValueAtTime(value, endTime);\n  }\n  linearRampToNormalizedParamValueAtTime(name, value, endTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.linearRampToNormalizedValueAtTime(value, endTime);\n  }\n  exponentialRampToParamValueAtTime(name, value, endTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.exponentialRampToValueAtTime(value, endTime);\n  }\n  exponentialRampToNormalizedParamValueAtTime(name, value, endTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.exponentialRampToNormalizedValueAtTime(value, endTime);\n  }\n  setParamTargetAtTime(name, target, startTime, timeConstant) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setTargetAtTime(target, startTime, timeConstant);\n  }\n  setNormalizedParamTargetAtTime(name, target, startTime, timeConstant) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setNormalizedTargetAtTime(target, startTime, timeConstant);\n  }\n  setParamValueCurveAtTime(name, values, startTime, duration) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setValueCurveAtTime(values, startTime, duration);\n  }\n  setNormalizedParamValueCurveAtTime(name, values, startTime, duration) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setNormalizedValueCurveAtTime(values, startTime, duration);\n  }\n  cancelScheduledParamValues(name, cancelTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.cancelScheduledValues(cancelTime);\n  }\n  cancelAndHoldParamAtTime(name, cancelTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.cancelAndHoldAtTime(cancelTime);\n  }\n  connectEvents(toId, output) {\n    this.call(\"connectEvents\", toId, output);\n  }\n  disconnectEvents(toId, output) {\n    this.call(\"disconnectEvents\", toId, output);\n  }\n  async destroy() {\n    this.disconnect();\n    this.paramsUpdateCheckFnRef.forEach((ref) => {\n      if (typeof ref === \"number\")\n        window.clearTimeout(ref);\n    });\n    await this.call(\"destroy\");\n    this.port.close();\n  }\n};\n\n// src/ParamMgrFactory.js\nvar ParamMgrFactory = class {\n  static async create(module, optionsIn = {}) {\n    const { audioContext, groupId, moduleId, instanceId } = module;\n    const { paramsConfig, paramsMapping, internalParamsConfig } = new ParamMappingConfigurator(optionsIn);\n    const initialParamsValue = Object.entries(paramsConfig).reduce((currentParams, [name, { defaultValue }]) => {\n      currentParams[name] = defaultValue;\n      return currentParams;\n    }, {});\n    const serializableParamsConfig = Object.entries(paramsConfig).reduce((currentParams, [name, { id, label, type, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units }]) => {\n      currentParams[name] = { id, label, type, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units };\n      return currentParams;\n    }, {});\n    await addFunctionModule_default(audioContext.audioWorklet, ParamMgrProcessor_default, moduleId, serializableParamsConfig);\n    const options = {\n      internalParamsConfig,\n      parameterData: initialParamsValue,\n      processorOptions: {\n        paramsConfig,\n        paramsMapping,\n        internalParamsMinValues: Object.values(internalParamsConfig).map((config) => Math.max(0, (config == null ? void 0 : config.minValue) || 0)),\n        internalParams: Object.keys(internalParamsConfig),\n        groupId,\n        instanceId,\n        moduleId\n      }\n    };\n    const node = new ParamMgrNode(module, options);\n    await node.initialize();\n    return node;\n  }\n};\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://soundfont-wam/../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js?");

/***/ }),

/***/ "../../../node_modules/@webaudiomodules/sdk/dist/index.js":
/*!****************************************************************!*\
  !*** ../../../node_modules/@webaudiomodules/sdk/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WamNode\": () => (/* binding */ WamNode),\n/* harmony export */   \"WebAudioModule\": () => (/* binding */ WebAudioModule_default),\n/* harmony export */   \"addFunctionModule\": () => (/* binding */ addFunctionModule_default),\n/* harmony export */   \"apiVersion\": () => (/* binding */ apiVersion_default),\n/* harmony export */   \"getRingBuffer\": () => (/* binding */ RingBuffer_default),\n/* harmony export */   \"getWamArrayRingBuffer\": () => (/* binding */ WamArrayRingBuffer_default),\n/* harmony export */   \"getWamEventRingBuffer\": () => (/* binding */ WamEventRingBuffer_default),\n/* harmony export */   \"getWamParameter\": () => (/* binding */ WamParameter_default),\n/* harmony export */   \"getWamParameterInfo\": () => (/* binding */ WamParameterInfo_default),\n/* harmony export */   \"getWamParameterInterpolator\": () => (/* binding */ WamParameterInterpolator_default),\n/* harmony export */   \"getWamProcessor\": () => (/* binding */ WamProcessor_default),\n/* harmony export */   \"initializeWamEnv\": () => (/* binding */ WamEnv_default),\n/* harmony export */   \"initializeWamGroup\": () => (/* binding */ WamGroup_default),\n/* harmony export */   \"initializeWamHost\": () => (/* binding */ initializeWamHost_default)\n/* harmony export */ });\n// src/WebAudioModule.js\nvar WebAudioModule = class {\n  static get isWebAudioModuleConstructor() {\n    return true;\n  }\n  static createInstance(groupId, audioContext, initialState) {\n    return new this(groupId, audioContext).initialize(initialState);\n  }\n  constructor(groupId, audioContext) {\n    this._groupId = groupId;\n    this._audioContext = audioContext;\n    this._initialized = false;\n    this._audioNode = void 0;\n    this._timestamp = performance.now();\n    this._guiModuleUrl = void 0;\n    this._descriptorUrl = \"./descriptor.json\";\n    this._descriptor = {\n      identifier: `com.webaudiomodule.default`,\n      name: `WebAudioModule_${this.constructor.name}`,\n      vendor: \"WebAudioModuleVendor\",\n      description: \"\",\n      version: \"0.0.0\",\n      apiVersion: \"2.0.0\",\n      thumbnail: \"\",\n      keywords: [],\n      isInstrument: false,\n      website: \"\",\n      hasAudioInput: true,\n      hasAudioOutput: true,\n      hasAutomationInput: true,\n      hasAutomationOutput: true,\n      hasMidiInput: true,\n      hasMidiOutput: true,\n      hasMpeInput: true,\n      hasMpeOutput: true,\n      hasOscInput: true,\n      hasOscOutput: true,\n      hasSysexInput: true,\n      hasSysexOutput: true\n    };\n  }\n  get isWebAudioModule() {\n    return true;\n  }\n  get groupId() {\n    return this._groupId;\n  }\n  get moduleId() {\n    return this.descriptor.identifier;\n  }\n  get instanceId() {\n    return this.moduleId + this._timestamp;\n  }\n  get descriptor() {\n    return this._descriptor;\n  }\n  get identifier() {\n    return this.descriptor.identifier;\n  }\n  get name() {\n    return this.descriptor.name;\n  }\n  get vendor() {\n    return this.descriptor.vendor;\n  }\n  get audioContext() {\n    return this._audioContext;\n  }\n  get audioNode() {\n    if (!this.initialized)\n      console.warn(\"WAM should be initialized before getting the audioNode\");\n    return this._audioNode;\n  }\n  set audioNode(node) {\n    this._audioNode = node;\n  }\n  get initialized() {\n    return this._initialized;\n  }\n  set initialized(value) {\n    this._initialized = value;\n  }\n  async createAudioNode(initialState) {\n    throw new TypeError(\"createAudioNode() not provided\");\n  }\n  async initialize(state) {\n    if (!this._audioNode)\n      this.audioNode = await this.createAudioNode();\n    this.initialized = true;\n    return this;\n  }\n  async _loadGui() {\n    const url = this._guiModuleUrl;\n    if (!url)\n      throw new TypeError(\"Gui module not found\");\n    return import(\n      /* webpackIgnore: true */\n      url\n    );\n  }\n  async _loadDescriptor() {\n    const url = this._descriptorUrl;\n    if (!url)\n      throw new TypeError(\"Descriptor not found\");\n    const response = await fetch(url);\n    const descriptor = await response.json();\n    Object.assign(this._descriptor, descriptor);\n    return this._descriptor;\n  }\n  async createGui() {\n    if (!this.initialized)\n      console.warn(\"Plugin should be initialized before getting the gui\");\n    if (!this._guiModuleUrl)\n      return void 0;\n    const { createElement } = await this._loadGui();\n    return createElement(this);\n  }\n  destroyGui() {\n  }\n};\nvar WebAudioModule_default = WebAudioModule;\n\n// src/RingBuffer.js\nvar getRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class RingBuffer2 {\n    static getStorageForCapacity(capacity, Type) {\n      if (!Type.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      const bytes = 8 + (capacity + 1) * Type.BYTES_PER_ELEMENT;\n      return new SharedArrayBuffer(bytes);\n    }\n    constructor(sab, Type) {\n      if (!Type.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass a concrete typed array class as second argument\");\n      }\n      this._Type = Type;\n      this._capacity = (sab.byteLength - 8) / Type.BYTES_PER_ELEMENT;\n      this.buf = sab;\n      this.write_ptr = new Uint32Array(this.buf, 0, 1);\n      this.read_ptr = new Uint32Array(this.buf, 4, 1);\n      this.storage = new Type(this.buf, 8, this._capacity);\n    }\n    get type() {\n      return this._Type.name;\n    }\n    push(elements) {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      if ((wr + 1) % this._storageCapacity() === rd) {\n        return 0;\n      }\n      const toWrite = Math.min(this._availableWrite(rd, wr), elements.length);\n      const firstPart = Math.min(this._storageCapacity() - wr, toWrite);\n      const secondPart = toWrite - firstPart;\n      this._copy(elements, 0, this.storage, wr, firstPart);\n      this._copy(elements, firstPart, this.storage, 0, secondPart);\n      Atomics.store(this.write_ptr, 0, (wr + toWrite) % this._storageCapacity());\n      return toWrite;\n    }\n    pop(elements) {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      if (wr === rd) {\n        return 0;\n      }\n      const isArray = !Number.isInteger(elements);\n      const toRead = Math.min(this._availableRead(rd, wr), isArray ? elements.length : elements);\n      if (isArray) {\n        const firstPart = Math.min(this._storageCapacity() - rd, toRead);\n        const secondPart = toRead - firstPart;\n        this._copy(this.storage, rd, elements, 0, firstPart);\n        this._copy(this.storage, 0, elements, firstPart, secondPart);\n      }\n      Atomics.store(this.read_ptr, 0, (rd + toRead) % this._storageCapacity());\n      return toRead;\n    }\n    get empty() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return wr === rd;\n    }\n    get full() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return (wr + 1) % this._capacity !== rd;\n    }\n    get capacity() {\n      return this._capacity - 1;\n    }\n    get availableRead() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return this._availableRead(rd, wr);\n    }\n    get availableWrite() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return this._availableWrite(rd, wr);\n    }\n    _availableRead(rd, wr) {\n      if (wr > rd) {\n        return wr - rd;\n      }\n      return wr + this._storageCapacity() - rd;\n    }\n    _availableWrite(rd, wr) {\n      let rv = rd - wr - 1;\n      if (wr >= rd) {\n        rv += this._storageCapacity();\n      }\n      return rv;\n    }\n    _storageCapacity() {\n      return this._capacity;\n    }\n    _copy(input, offsetInput, output, offsetOutput, size) {\n      for (let i = 0; i < size; i++) {\n        output[offsetOutput + i] = input[offsetInput + i];\n      }\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.RingBuffer)\n      ModuleScope.RingBuffer = RingBuffer2;\n  }\n  return RingBuffer2;\n};\nvar RingBuffer_default = getRingBuffer;\n\n// src/WamArrayRingBuffer.js\nvar getWamArrayRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamArrayRingBuffer {\n    static DefaultArrayCapacity = 2;\n    static getStorageForEventCapacity(RingBuffer2, arrayLength, arrayType, maxArrayCapacity = void 0) {\n      if (maxArrayCapacity === void 0)\n        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n      else\n        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n      if (!arrayType.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      const capacity = arrayLength * maxArrayCapacity;\n      return RingBuffer2.getStorageForCapacity(capacity, arrayType);\n    }\n    constructor(RingBuffer2, sab, arrayLength, arrayType, maxArrayCapacity = void 0) {\n      if (!arrayType.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      this._arrayLength = arrayLength;\n      this._arrayType = arrayType;\n      this._arrayElementSizeBytes = arrayType.BYTES_PER_ELEMENT;\n      this._arraySizeBytes = this._arrayLength * this._arrayElementSizeBytes;\n      this._sab = sab;\n      if (maxArrayCapacity === void 0)\n        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n      else\n        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n      this._arrayArray = new arrayType(this._arrayLength);\n      this._rb = new RingBuffer2(this._sab, arrayType);\n    }\n    write(array) {\n      if (array.length !== this._arrayLength)\n        return false;\n      const elementsAvailable = this._rb.availableWrite;\n      if (elementsAvailable < this._arrayLength)\n        return false;\n      let success = true;\n      const elementsWritten = this._rb.push(array);\n      if (elementsWritten != this._arrayLength)\n        success = false;\n      return success;\n    }\n    read(array, newest) {\n      if (array.length !== this._arrayLength)\n        return false;\n      const elementsAvailable = this._rb.availableRead;\n      if (elementsAvailable < this._arrayLength)\n        return false;\n      if (newest && elementsAvailable > this._arrayLength)\n        this._rb.pop(elementsAvailable - this._arrayLength);\n      let success = false;\n      const elementsRead = this._rb.pop(array);\n      if (elementsRead === this._arrayLength)\n        success = true;\n      return success;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamArrayRingBuffer)\n      ModuleScope.WamArrayRingBuffer = WamArrayRingBuffer;\n  }\n  return WamArrayRingBuffer;\n};\nvar WamArrayRingBuffer_default = getWamArrayRingBuffer;\n\n// src/WamEnv.js\nvar initializeWamEnv = (apiVersion) => {\n  const audioWorkletGlobalScope = globalThis;\n  if (audioWorkletGlobalScope.AudioWorkletProcessor && audioWorkletGlobalScope.webAudioModules)\n    return;\n  const moduleScopes = /* @__PURE__ */ new Map();\n  const groups = /* @__PURE__ */ new Map();\n  class WamEnv {\n    constructor() {\n    }\n    get apiVersion() {\n      return apiVersion;\n    }\n    getModuleScope(moduleId) {\n      if (!moduleScopes.has(moduleId))\n        moduleScopes.set(moduleId, {});\n      return moduleScopes.get(moduleId);\n    }\n    getGroup(groupId, groupKey) {\n      const group = groups.get(groupId);\n      if (group.validate(groupKey))\n        return group;\n      else\n        throw \"Invalid key\";\n    }\n    addGroup(group) {\n      if (!groups.has(group.groupId))\n        groups.set(group.groupId, group);\n    }\n    removeGroup(group) {\n      groups.delete(group.groupId);\n    }\n    addWam(wam) {\n      const group = groups.get(wam.groupId);\n      group.addWam(wam);\n    }\n    removeWam(wam) {\n      const group = groups.get(wam.groupId);\n      group.removeWam(wam);\n    }\n    connectEvents(groupId, fromId, toId, output = 0) {\n      const group = groups.get(groupId);\n      group.connectEvents(fromId, toId, output);\n    }\n    disconnectEvents(groupId, fromId, toId, output) {\n      const group = groups.get(groupId);\n      group.disconnectEvents(fromId, toId, output);\n    }\n    emitEvents(from, ...events) {\n      const group = groups.get(from.groupId);\n      group.emitEvents(from, ...events);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    if (!audioWorkletGlobalScope.webAudioModules)\n      audioWorkletGlobalScope.webAudioModules = new WamEnv();\n  }\n};\nvar WamEnv_default = initializeWamEnv;\n\n// src/WamGroup.js\nvar initializeWamGroup = (groupId, groupKey) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamGroup {\n    constructor(groupId2, groupKey2) {\n      this._groupId = groupId2;\n      this._validate = (key) => {\n        return key == groupKey2;\n      };\n      this._processors = /* @__PURE__ */ new Map();\n      this._eventGraph = /* @__PURE__ */ new Map();\n    }\n    get groupId() {\n      return this._groupId;\n    }\n    get processors() {\n      return this._processors;\n    }\n    get eventGraph() {\n      return this._eventGraph;\n    }\n    validate(groupKey2) {\n      return this._validate(groupKey2);\n    }\n    addWam(wam) {\n      this._processors.set(wam.instanceId, wam);\n    }\n    removeWam(wam) {\n      if (this._eventGraph.has(wam))\n        this._eventGraph.delete(wam);\n      this._eventGraph.forEach((outputMap) => {\n        outputMap.forEach((set) => {\n          if (set && set.has(wam))\n            set.delete(wam);\n        });\n      });\n      this._processors.delete(wam.instanceId);\n    }\n    connectEvents(fromId, toId, output) {\n      const from = this._processors.get(fromId);\n      const to = this._processors.get(toId);\n      let outputMap;\n      if (this._eventGraph.has(from)) {\n        outputMap = this._eventGraph.get(from);\n      } else {\n        outputMap = [];\n        this._eventGraph.set(from, outputMap);\n      }\n      if (outputMap[output]) {\n        outputMap[output].add(to);\n      } else {\n        const set = /* @__PURE__ */ new Set();\n        set.add(to);\n        outputMap[output] = set;\n      }\n    }\n    disconnectEvents(fromId, toId, output) {\n      const from = this._processors.get(fromId);\n      if (!this._eventGraph.has(from))\n        return;\n      const outputMap = this._eventGraph.get(from);\n      if (typeof toId === \"undefined\") {\n        outputMap.forEach((set) => {\n          if (set)\n            set.clear();\n        });\n        return;\n      }\n      const to = this._processors.get(toId);\n      if (typeof output === \"undefined\") {\n        outputMap.forEach((set) => {\n          if (set)\n            set.delete(to);\n        });\n        return;\n      }\n      if (!outputMap[output])\n        return;\n      outputMap[output].delete(to);\n    }\n    emitEvents(from, ...events) {\n      if (!this._eventGraph.has(from))\n        return;\n      const downstream = this._eventGraph.get(from);\n      downstream.forEach((set) => {\n        if (set)\n          set.forEach((wam) => wam.scheduleEvents(...events));\n      });\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    audioWorkletGlobalScope.webAudioModules.addGroup(new WamGroup(groupId, groupKey));\n  }\n};\nvar WamGroup_default = initializeWamGroup;\n\n// src/WamEventRingBuffer.js\nvar getWamEventRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamEventRingBuffer2 {\n    static DefaultExtraBytesPerEvent = 64;\n    static WamEventBaseBytes = 4 + 1 + 8;\n    static WamAutomationEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 2 + 8 + 1;\n    static WamTransportEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4 + 8 + 8 + 1 + 1 + 1;\n    static WamMidiEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 1 + 1 + 1;\n    static WamBinaryEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4;\n    static getStorageForEventCapacity(RingBuffer2, eventCapacity, maxBytesPerEvent = void 0) {\n      if (maxBytesPerEvent === void 0)\n        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n      else\n        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n      const capacity = (Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent) * eventCapacity;\n      return RingBuffer2.getStorageForCapacity(capacity, Uint8Array);\n    }\n    constructor(RingBuffer2, sab, parameterIds, maxBytesPerEvent = void 0) {\n      this._eventSizeBytes = {};\n      this._encodeEventType = {};\n      this._decodeEventType = {};\n      const wamEventTypes = [\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\", \"wam-info\"];\n      wamEventTypes.forEach((type, encodedType) => {\n        let byteSize = 0;\n        switch (type) {\n          case \"wam-automation\":\n            byteSize = WamEventRingBuffer2.WamAutomationEventBytes;\n            break;\n          case \"wam-transport\":\n            byteSize = WamEventRingBuffer2.WamTransportEventBytes;\n            break;\n          case \"wam-mpe\":\n          case \"wam-midi\":\n            byteSize = WamEventRingBuffer2.WamMidiEventBytes;\n            break;\n          case \"wam-osc\":\n          case \"wam-sysex\":\n          case \"wam-info\":\n            byteSize = WamEventRingBuffer2.WamBinaryEventBytes;\n            break;\n          default:\n            break;\n        }\n        this._eventSizeBytes[type] = byteSize;\n        this._encodeEventType[type] = encodedType;\n        this._decodeEventType[encodedType] = type;\n      });\n      this._parameterCode = 0;\n      this._parameterCodes = {};\n      this._encodeParameterId = {};\n      this._decodeParameterId = {};\n      this.setParameterIds(parameterIds);\n      this._sab = sab;\n      if (maxBytesPerEvent === void 0)\n        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n      else\n        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n      this._eventBytesAvailable = Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent;\n      this._eventBytes = new ArrayBuffer(this._eventBytesAvailable);\n      this._eventBytesView = new DataView(this._eventBytes);\n      this._rb = new RingBuffer2(this._sab, Uint8Array);\n      this._eventSizeArray = new Uint8Array(this._eventBytes, 0, 4);\n      this._eventSizeView = new DataView(this._eventBytes, 0, 4);\n    }\n    _writeHeader(byteSize, type, time) {\n      let byteOffset = 0;\n      this._eventBytesView.setUint32(byteOffset, byteSize);\n      byteOffset += 4;\n      this._eventBytesView.setUint8(byteOffset, this._encodeEventType[type]);\n      byteOffset += 1;\n      this._eventBytesView.setFloat64(byteOffset, Number.isFinite(time) ? time : -1);\n      byteOffset += 8;\n      return byteOffset;\n    }\n    _encode(event) {\n      let byteOffset = 0;\n      const { type, time } = event;\n      switch (event.type) {\n        case \"wam-automation\":\n          {\n            if (!(event.data.id in this._encodeParameterId))\n              break;\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const encodedParameterId = this._encodeParameterId[data.id];\n            const { value, normalized } = data;\n            this._eventBytesView.setUint16(byteOffset, encodedParameterId);\n            byteOffset += 2;\n            this._eventBytesView.setFloat64(byteOffset, value);\n            byteOffset += 8;\n            this._eventBytesView.setUint8(byteOffset, normalized ? 1 : 0);\n            byteOffset += 1;\n          }\n          break;\n        case \"wam-transport\":\n          {\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const {\n              currentBar,\n              currentBarStarted,\n              tempo,\n              timeSigNumerator,\n              timeSigDenominator,\n              playing\n            } = data;\n            this._eventBytesView.setUint32(byteOffset, currentBar);\n            byteOffset += 4;\n            this._eventBytesView.setFloat64(byteOffset, currentBarStarted);\n            byteOffset += 8;\n            this._eventBytesView.setFloat64(byteOffset, tempo);\n            byteOffset += 8;\n            this._eventBytesView.setUint8(byteOffset, timeSigNumerator);\n            byteOffset += 1;\n            this._eventBytesView.setUint8(byteOffset, timeSigDenominator);\n            byteOffset += 1;\n            this._eventBytesView.setUint8(byteOffset, playing ? 1 : 0);\n            byteOffset += 1;\n          }\n          break;\n        case \"wam-mpe\":\n        case \"wam-midi\":\n          {\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const { bytes } = data;\n            let b = 0;\n            while (b < 3) {\n              this._eventBytesView.setUint8(byteOffset, bytes[b]);\n              byteOffset += 1;\n              b++;\n            }\n          }\n          break;\n        case \"wam-osc\":\n        case \"wam-sysex\":\n        case \"wam-info\":\n          {\n            let bytes = null;\n            if (event.type === \"wam-info\") {\n              const { data } = event;\n              bytes = new TextEncoder().encode(data.instanceId);\n            } else {\n              const { data } = event;\n              bytes = data.bytes;\n            }\n            const numBytes = bytes.length;\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize + numBytes, type, time);\n            this._eventBytesView.setUint32(byteOffset, numBytes);\n            byteOffset += 4;\n            const bytesRequired = byteOffset + numBytes;\n            if (bytesRequired > this._eventBytesAvailable)\n              console.error(`Event requires ${bytesRequired} bytes but only ${this._eventBytesAvailable} have been allocated!`);\n            const buffer = new Uint8Array(this._eventBytes, byteOffset, numBytes);\n            buffer.set(bytes);\n            byteOffset += numBytes;\n          }\n          break;\n        default:\n          break;\n      }\n      return new Uint8Array(this._eventBytes, 0, byteOffset);\n    }\n    _decode() {\n      let byteOffset = 0;\n      const type = this._decodeEventType[this._eventBytesView.getUint8(byteOffset)];\n      byteOffset += 1;\n      let time = this._eventBytesView.getFloat64(byteOffset);\n      if (time === -1)\n        time = void 0;\n      byteOffset += 8;\n      switch (type) {\n        case \"wam-automation\": {\n          const encodedParameterId = this._eventBytesView.getUint16(byteOffset);\n          byteOffset += 2;\n          const value = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const normalized = !!this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          if (!(encodedParameterId in this._decodeParameterId))\n            break;\n          const id = this._decodeParameterId[encodedParameterId];\n          const event = {\n            type,\n            time,\n            data: {\n              id,\n              value,\n              normalized\n            }\n          };\n          return event;\n        }\n        case \"wam-transport\": {\n          const currentBar = this._eventBytesView.getUint32(byteOffset);\n          byteOffset += 4;\n          const currentBarStarted = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const tempo = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const timeSigNumerator = this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          const timeSigDenominator = this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          const playing = this._eventBytesView.getUint8(byteOffset) == 1;\n          byteOffset += 1;\n          const event = {\n            type,\n            time,\n            data: {\n              currentBar,\n              currentBarStarted,\n              tempo,\n              timeSigNumerator,\n              timeSigDenominator,\n              playing\n            }\n          };\n          return event;\n        }\n        case \"wam-mpe\":\n        case \"wam-midi\": {\n          const bytes = [0, 0, 0];\n          let b = 0;\n          while (b < 3) {\n            bytes[b] = this._eventBytesView.getUint8(byteOffset);\n            byteOffset += 1;\n            b++;\n          }\n          const event = {\n            type,\n            time,\n            data: { bytes }\n          };\n          return event;\n        }\n        case \"wam-osc\":\n        case \"wam-sysex\":\n        case \"wam-info\": {\n          const numBytes = this._eventBytesView.getUint32(byteOffset);\n          byteOffset += 4;\n          const bytes = new Uint8Array(numBytes);\n          bytes.set(new Uint8Array(this._eventBytes, byteOffset, numBytes));\n          byteOffset += numBytes;\n          if (type === \"wam-info\") {\n            const instanceId = new TextDecoder().decode(bytes);\n            const data = { instanceId };\n            return { type, time, data };\n          } else {\n            const data = { bytes };\n            return { type, time, data };\n          }\n        }\n        default:\n          break;\n      }\n      return false;\n    }\n    write(...events) {\n      const numEvents = events.length;\n      let bytesAvailable = this._rb.availableWrite;\n      let numSkipped = 0;\n      let i = 0;\n      while (i < numEvents) {\n        const event = events[i];\n        const bytes = this._encode(event);\n        const eventSizeBytes = bytes.byteLength;\n        let bytesWritten = 0;\n        if (bytesAvailable >= eventSizeBytes) {\n          if (eventSizeBytes === 0)\n            numSkipped++;\n          else\n            bytesWritten = this._rb.push(bytes);\n        } else\n          break;\n        bytesAvailable -= bytesWritten;\n        i++;\n      }\n      return i - numSkipped;\n    }\n    read() {\n      if (this._rb.empty)\n        return [];\n      const events = [];\n      let bytesAvailable = this._rb.availableRead;\n      let bytesRead = 0;\n      while (bytesAvailable > 0) {\n        bytesRead = this._rb.pop(this._eventSizeArray);\n        bytesAvailable -= bytesRead;\n        const eventSizeBytes = this._eventSizeView.getUint32(0);\n        const eventBytes = new Uint8Array(this._eventBytes, 0, eventSizeBytes - 4);\n        bytesRead = this._rb.pop(eventBytes);\n        bytesAvailable -= bytesRead;\n        const decodedEvent = this._decode();\n        if (decodedEvent)\n          events.push(decodedEvent);\n      }\n      return events;\n    }\n    setParameterIds(parameterIds) {\n      this._encodeParameterId = {};\n      this._decodeParameterId = {};\n      parameterIds.forEach((parameterId) => {\n        let parameterCode = -1;\n        if (parameterId in this._parameterCodes)\n          parameterCode = this._parameterCodes[parameterId];\n        else {\n          parameterCode = this._generateParameterCode();\n          this._parameterCodes[parameterId] = parameterCode;\n        }\n        this._encodeParameterId[parameterId] = parameterCode;\n        this._decodeParameterId[parameterCode] = parameterId;\n      });\n    }\n    _generateParameterCode() {\n      if (this._parameterCode > 65535)\n        throw Error(\"Too many parameters have been registered!\");\n      return this._parameterCode++;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamEventRingBuffer)\n      ModuleScope.WamEventRingBuffer = WamEventRingBuffer2;\n  }\n  return WamEventRingBuffer2;\n};\nvar WamEventRingBuffer_default = getWamEventRingBuffer;\n\n// src/addFunctionModule.js\nvar addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\n  const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(\", \")});`;\n  const url = URL.createObjectURL(new Blob([text], { type: \"text/javascript\" }));\n  return audioWorklet.addModule(url);\n};\nvar addFunctionModule_default = addFunctionModule;\n\n// src/WamParameter.js\nvar getWamParameter = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamParameter {\n    constructor(info) {\n      this.info = info;\n      this._value = info.defaultValue;\n    }\n    set value(value) {\n      this._value = value;\n    }\n    get value() {\n      return this._value;\n    }\n    set normalizedValue(valueNorm) {\n      this.value = this.info.denormalize(valueNorm);\n    }\n    get normalizedValue() {\n      return this.info.normalize(this.value);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameter)\n      ModuleScope.WamParameter = WamParameter;\n  }\n  return WamParameter;\n};\nvar WamParameter_default = getWamParameter;\n\n// src/WamParameterInfo.js\nvar getWamParameterInfo = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n  const denormExp = (x, e) => e === 0 ? x : x ** 1.5 ** e;\n  const normalize = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n  const denormalize = (x, min, max, e = 0) => min === 0 && max === 1 ? denormExp(x, e) : denormExp(x, e) * (max - min) + min;\n  const inRange = (x, min, max) => x >= min && x <= max;\n  class WamParameterInfo {\n    constructor(id, config = {}) {\n      let {\n        type,\n        label,\n        defaultValue,\n        minValue,\n        maxValue,\n        discreteStep,\n        exponent,\n        choices,\n        units\n      } = config;\n      if (type === void 0)\n        type = \"float\";\n      if (label === void 0)\n        label = \"\";\n      if (defaultValue === void 0)\n        defaultValue = 0;\n      if (choices === void 0)\n        choices = [];\n      if (type === \"boolean\" || type === \"choice\") {\n        discreteStep = 1;\n        minValue = 0;\n        if (choices.length)\n          maxValue = choices.length - 1;\n        else\n          maxValue = 1;\n      } else {\n        if (minValue === void 0)\n          minValue = 0;\n        if (maxValue === void 0)\n          maxValue = 1;\n        if (discreteStep === void 0)\n          discreteStep = 0;\n        if (exponent === void 0)\n          exponent = 0;\n        if (units === void 0)\n          units = \"\";\n      }\n      const errBase = `Param config error | ${id}: `;\n      if (minValue >= maxValue)\n        throw Error(errBase.concat(\"minValue must be less than maxValue\"));\n      if (!inRange(defaultValue, minValue, maxValue))\n        throw Error(errBase.concat(\"defaultValue out of range\"));\n      if (discreteStep % 1 || discreteStep < 0) {\n        throw Error(errBase.concat(\"discreteStep must be a non-negative integer\"));\n      } else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n        throw Error(errBase.concat(\"non-zero discreteStep requires integer minValue, maxValue, and defaultValue\"));\n      }\n      if (type === \"choice\" && !choices.length) {\n        throw Error(errBase.concat(\"choice type parameter requires list of strings in choices\"));\n      }\n      this.id = id;\n      this.label = label;\n      this.type = type;\n      this.defaultValue = defaultValue;\n      this.minValue = minValue;\n      this.maxValue = maxValue;\n      this.discreteStep = discreteStep;\n      this.exponent = exponent;\n      this.choices = choices;\n      this.units = units;\n    }\n    normalize(value) {\n      return normalize(value, this.minValue, this.maxValue, this.exponent);\n    }\n    denormalize(valueNorm) {\n      return denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n    }\n    valueString(value) {\n      if (this.choices)\n        return this.choices[value];\n      if (this.units !== \"\")\n        return `${value} ${this.units}`;\n      return `${value}`;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameterInfo)\n      ModuleScope.WamParameterInfo = WamParameterInfo;\n  }\n  return WamParameterInfo;\n};\nvar WamParameterInfo_default = getWamParameterInfo;\n\n// src/WamParameterInterpolator.js\nvar getWamParameterInterpolator = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const samplesPerQuantum = 128;\n  const nullTableKey = \"0_0\";\n  class WamParameterInterpolator {\n    static _tables;\n    static _tableReferences;\n    constructor(info, samplesPerInterpolation, skew = 0) {\n      if (!WamParameterInterpolator._tables) {\n        WamParameterInterpolator._tables = { nullTableKey: new Float32Array(0) };\n        WamParameterInterpolator._tableReferences = { nullTableKey: [] };\n      }\n      this.info = info;\n      this.values = new Float32Array(samplesPerQuantum);\n      this._tableKey = nullTableKey;\n      this._table = WamParameterInterpolator._tables[this._tableKey];\n      this._skew = 2;\n      const { discreteStep } = info;\n      this._discrete = !!discreteStep;\n      this._N = this._discrete ? 0 : samplesPerInterpolation;\n      this._n = 0;\n      this._startValue = info.defaultValue;\n      this._endValue = info.defaultValue;\n      this._currentValue = info.defaultValue;\n      this._deltaValue = 0;\n      this._inverted = false;\n      this._changed = true;\n      this._filled = 0;\n      if (!this._discrete)\n        this.setSkew(skew);\n      else\n        this._skew = 0;\n      this.setStartValue(this._startValue);\n    }\n    _removeTableReference(oldKey) {\n      if (oldKey === nullTableKey)\n        return;\n      const { id } = this.info;\n      const references = WamParameterInterpolator._tableReferences[oldKey];\n      if (references) {\n        const index = references.indexOf(id);\n        if (index !== -1)\n          references.splice(index, 1);\n        if (references.length === 0) {\n          delete WamParameterInterpolator._tables[oldKey];\n          delete WamParameterInterpolator._tableReferences[oldKey];\n        }\n      }\n    }\n    setSkew(skew) {\n      if (this._skew === skew || this._discrete)\n        return;\n      if (skew < -1 || skew > 1)\n        throw Error(\"skew must be in range [-1.0, 1.0]\");\n      const newKey = [this._N, skew].join(\"_\");\n      const oldKey = this._tableKey;\n      const { id } = this.info;\n      if (newKey === oldKey)\n        return;\n      if (WamParameterInterpolator._tables[newKey]) {\n        const references = WamParameterInterpolator._tableReferences[newKey];\n        if (references)\n          references.push(id);\n        else\n          WamParameterInterpolator._tableReferences[newKey] = [id];\n      } else {\n        let e = Math.abs(skew);\n        e = Math.pow(3 - e, e * (e + 2));\n        const linear = e === 1;\n        const N = this._N;\n        const table = new Float32Array(N + 1);\n        if (linear)\n          for (let n = 0; n <= N; ++n)\n            table[n] = n / N;\n        else\n          for (let n = 0; n <= N; ++n)\n            table[n] = (n / N) ** e;\n        WamParameterInterpolator._tables[newKey] = table;\n        WamParameterInterpolator._tableReferences[newKey] = [id];\n      }\n      this._removeTableReference(oldKey);\n      this._skew = skew;\n      this._tableKey = newKey;\n      this._table = WamParameterInterpolator._tables[this._tableKey];\n    }\n    setStartValue(value, fill = true) {\n      this._n = this._N;\n      this._startValue = value;\n      this._endValue = value;\n      this._currentValue = value;\n      this._deltaValue = 0;\n      this._inverted = false;\n      if (fill) {\n        this.values.fill(value);\n        this._changed = true;\n        this._filled = this.values.length;\n      } else {\n        this._changed = false;\n        this._filled = 0;\n      }\n    }\n    setEndValue(value) {\n      if (value === this._endValue)\n        return;\n      this._n = 0;\n      this._startValue = this._currentValue;\n      this._endValue = value;\n      this._deltaValue = this._endValue - this._startValue;\n      this._inverted = this._deltaValue > 0 && this._skew >= 0 || this._deltaValue <= 0 && this._skew < 0;\n      this._changed = false;\n      this._filled = 0;\n    }\n    process(startSample, endSample) {\n      if (this.done)\n        return;\n      const length = endSample - startSample;\n      let fill = 0;\n      const change = this._N - this._n;\n      if (this._discrete || !change)\n        fill = length;\n      else {\n        if (change < length) {\n          fill = Math.min(length - change, samplesPerQuantum);\n          endSample -= fill;\n        }\n        if (endSample > startSample) {\n          if (this._inverted) {\n            for (let i = startSample; i < endSample; ++i) {\n              const tableValue = 1 - this._table[this._N - ++this._n];\n              this.values[i] = this._startValue + tableValue * this._deltaValue;\n            }\n          } else {\n            for (let i = startSample; i < endSample; ++i) {\n              const tableValue = this._table[++this._n];\n              this.values[i] = this._startValue + tableValue * this._deltaValue;\n            }\n          }\n        }\n        if (fill > 0) {\n          startSample = endSample;\n          endSample += fill;\n        }\n      }\n      if (fill > 0) {\n        this.values.fill(this._endValue, startSample, endSample);\n        this._filled += fill;\n      }\n      this._currentValue = this.values[endSample - 1];\n      if (this._n === this._N) {\n        if (!this._changed)\n          this._changed = true;\n        else if (this._filled >= this.values.length) {\n          this.setStartValue(this._endValue, false);\n          this._changed = true;\n          this._filled = this.values.length;\n        }\n      }\n    }\n    get done() {\n      return this._changed && this._filled === this.values.length;\n    }\n    is(value) {\n      return this._endValue === value && this.done;\n    }\n    destroy() {\n      this._removeTableReference(this._tableKey);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameterInterpolator)\n      ModuleScope.WamParameterInterpolator = WamParameterInterpolator;\n  }\n  return WamParameterInterpolator;\n};\nvar WamParameterInterpolator_default = getWamParameterInterpolator;\n\n// src/WamProcessor.js\nvar getWamProcessor = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const {\n    AudioWorkletProcessor,\n    webAudioModules\n  } = audioWorkletGlobalScope;\n  const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n  const {\n    RingBuffer: RingBuffer2,\n    WamEventRingBuffer: WamEventRingBuffer2,\n    WamParameter,\n    WamParameterInterpolator\n  } = ModuleScope;\n  class WamProcessor extends AudioWorkletProcessor {\n    constructor(options) {\n      super();\n      const {\n        groupId,\n        moduleId: moduleId2,\n        instanceId,\n        useSab\n      } = options.processorOptions;\n      if (!moduleId2)\n        throw Error(\"must provide moduleId argument in processorOptions!\");\n      if (!instanceId)\n        throw Error(\"must provide instanceId argument in processorOptions!\");\n      this.groupId = groupId;\n      this.moduleId = moduleId2;\n      this.instanceId = instanceId;\n      this._samplesPerQuantum = 128;\n      this._compensationDelay = 0;\n      this._parameterInfo = {};\n      this._parameterState = {};\n      this._parameterInterpolators = {};\n      this._eventQueue = [];\n      this._pendingResponses = {};\n      this._useSab = !!useSab && !!globalThis.SharedArrayBuffer;\n      this._eventSabReady = false;\n      this._audioToMainEventSab = null;\n      this._mainToAudioEventSab = null;\n      this._eventWriter = null;\n      this._eventReader = null;\n      this._initialized = false;\n      this._destroyed = false;\n      webAudioModules.addWam(this);\n      this.port.onmessage = this._onMessage.bind(this);\n      if (this._useSab)\n        this._configureSab();\n    }\n    getCompensationDelay() {\n      return this._compensationDelay;\n    }\n    scheduleEvents(...events) {\n      let i = 0;\n      while (i < events.length) {\n        this._eventQueue.push({ id: 0, event: events[i] });\n        i++;\n      }\n      this._eventQueue.sort((a, b) => a.event.time - b.event.time);\n    }\n    emitEvents(...events) {\n      webAudioModules.emitEvents(this, ...events);\n    }\n    clearEvents() {\n      this._eventQueue = [];\n    }\n    process(inputs, outputs, parameters) {\n      if (!this._initialized)\n        return true;\n      if (this._destroyed)\n        return false;\n      if (this._eventSabReady)\n        this.scheduleEvents(...this._eventReader.read());\n      const processingSlices = this._getProcessingSlices();\n      let i = 0;\n      while (i < processingSlices.length) {\n        const { range, events } = processingSlices[i];\n        const [startSample, endSample] = range;\n        let j = 0;\n        while (j < events.length) {\n          this._processEvent(events[j]);\n          j++;\n        }\n        this._interpolateParameterValues(startSample, endSample);\n        this._process(startSample, endSample, inputs, outputs, parameters);\n        i++;\n      }\n      return true;\n    }\n    destroy() {\n      this._destroyed = true;\n      this.port.close();\n      webAudioModules.removeWam(this);\n    }\n    _generateWamParameterInfo() {\n      return {};\n    }\n    _initialize() {\n      this._parameterState = {};\n      this._parameterInterpolators = {};\n      this._parameterInfo = this._generateWamParameterInfo();\n      Object.keys(this._parameterInfo).forEach((parameterId) => {\n        const info = this._parameterInfo[parameterId];\n        this._parameterState[parameterId] = new WamParameter(this._parameterInfo[parameterId]);\n        this._parameterInterpolators[parameterId] = new WamParameterInterpolator(info, 256);\n      });\n    }\n    _configureSab() {\n      const eventCapacity = 2 ** 10;\n      const parameterIds = Object.keys(this._parameterInfo);\n      if (this._eventSabReady) {\n        this._eventWriter.setParameterIds(parameterIds);\n        this._eventReader.setParameterIds(parameterIds);\n      }\n      this.port.postMessage({ eventSab: { eventCapacity, parameterIds } });\n    }\n    async _onMessage(message) {\n      if (message.data.request) {\n        const {\n          id,\n          request,\n          content\n        } = message.data;\n        const response = { id, response: request };\n        const requestComponents = request.split(\"/\");\n        const verb = requestComponents[0];\n        const noun = requestComponents[1];\n        response.content = \"error\";\n        if (verb === \"get\") {\n          if (noun === \"parameterInfo\") {\n            let { parameterIds } = content;\n            if (!parameterIds.length)\n              parameterIds = Object.keys(this._parameterInfo);\n            const parameterInfo = {};\n            let i = 0;\n            while (i < parameterIds.length) {\n              const parameterId = parameterIds[i];\n              parameterInfo[parameterId] = this._parameterInfo[parameterId];\n              i++;\n            }\n            response.content = parameterInfo;\n          } else if (noun === \"parameterValues\") {\n            let { normalized, parameterIds } = content;\n            response.content = this._getParameterValues(normalized, parameterIds);\n          } else if (noun === \"state\") {\n            response.content = this._getState();\n          } else if (noun === \"compensationDelay\") {\n            response.content = this.getCompensationDelay();\n          }\n        } else if (verb === \"set\") {\n          if (noun === \"parameterValues\") {\n            const { parameterValues } = content;\n            this._setParameterValues(parameterValues, true);\n            delete response.content;\n          } else if (noun === \"state\") {\n            const { state } = content;\n            this._setState(state);\n            delete response.content;\n          }\n        } else if (verb === \"add\") {\n          if (noun === \"event\") {\n            const { event } = content;\n            this._eventQueue.push({ id, event });\n            return;\n          }\n        } else if (verb === \"remove\") {\n          if (noun === \"events\") {\n            const ids = this._eventQueue.map((queued) => queued.id);\n            this.clearEvents();\n            response.content = ids;\n          }\n        } else if (verb === \"connect\") {\n          if (noun === \"events\") {\n            const { wamInstanceId, output } = content;\n            this._connectEvents(wamInstanceId, output);\n            delete response.content;\n          }\n        } else if (verb === \"disconnect\") {\n          if (noun === \"events\") {\n            const { wamInstanceId, output } = content;\n            this._disconnectEvents(wamInstanceId, output);\n            delete response.content;\n          }\n        } else if (verb === \"initialize\") {\n          if (noun === \"processor\") {\n            this._initialize();\n            this._initialized = true;\n            delete response.content;\n          } else if (noun === \"eventSab\") {\n            const { mainToAudioEventSab, audioToMainEventSab } = content;\n            this._audioToMainEventSab = audioToMainEventSab;\n            this._mainToAudioEventSab = mainToAudioEventSab;\n            const parameterIds = Object.keys(this._parameterInfo);\n            this._eventWriter = new WamEventRingBuffer2(RingBuffer2, this._audioToMainEventSab, parameterIds);\n            this._eventReader = new WamEventRingBuffer2(RingBuffer2, this._mainToAudioEventSab, parameterIds);\n            this._eventSabReady = true;\n            delete response.content;\n          }\n        }\n        this.port.postMessage(response);\n      } else if (message.data.destroy) {\n        this.destroy();\n      }\n    }\n    _onTransport(transportData) {\n      console.error(\"_onTransport not implemented!\");\n    }\n    _onMidi(midiData) {\n      console.error(\"_onMidi not implemented!\");\n    }\n    _onSysex(sysexData) {\n      console.error(\"_onMidi not implemented!\");\n    }\n    _onMpe(mpeData) {\n      console.error(\"_onMpe not implemented!\");\n    }\n    _onOsc(oscData) {\n      console.error(\"_onOsc not implemented!\");\n    }\n    _setState(state) {\n      if (state.parameterValues)\n        this._setParameterValues(state.parameterValues, false);\n    }\n    _getState() {\n      return { parameterValues: this._getParameterValues(false) };\n    }\n    _getParameterValues(normalized, parameterIds) {\n      const parameterValues = {};\n      if (!parameterIds || !parameterIds.length)\n        parameterIds = Object.keys(this._parameterState);\n      let i = 0;\n      while (i < parameterIds.length) {\n        const id = parameterIds[i];\n        const parameter = this._parameterState[id];\n        parameterValues[id] = {\n          id,\n          value: normalized ? parameter.normalizedValue : parameter.value,\n          normalized\n        };\n        i++;\n      }\n      return parameterValues;\n    }\n    _setParameterValues(parameterUpdates, interpolate) {\n      const parameterIds = Object.keys(parameterUpdates);\n      let i = 0;\n      while (i < parameterIds.length) {\n        this._setParameterValue(parameterUpdates[parameterIds[i]], interpolate);\n        i++;\n      }\n    }\n    _setParameterValue(parameterUpdate, interpolate) {\n      const { id, value, normalized } = parameterUpdate;\n      const parameter = this._parameterState[id];\n      if (!parameter)\n        return;\n      if (!normalized)\n        parameter.value = value;\n      else\n        parameter.normalizedValue = value;\n      const interpolator = this._parameterInterpolators[id];\n      if (interpolate)\n        interpolator.setEndValue(parameter.value);\n      else\n        interpolator.setStartValue(parameter.value);\n    }\n    _interpolateParameterValues(startIndex, endIndex) {\n      const parameterIds = Object.keys(this._parameterInterpolators);\n      let i = 0;\n      while (i < parameterIds.length) {\n        this._parameterInterpolators[parameterIds[i]].process(startIndex, endIndex);\n        i++;\n      }\n    }\n    _connectEvents(wamInstanceId, output) {\n      webAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    _disconnectEvents(wamInstanceId, output) {\n      if (typeof wamInstanceId === \"undefined\") {\n        webAudioModules.disconnectEvents(this.groupId, this.instanceId);\n        return;\n      }\n      webAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    _getProcessingSlices() {\n      const response = \"add/event\";\n      const { currentTime, sampleRate } = audioWorkletGlobalScope;\n      const eventsBySampleIndex = {};\n      let i = 0;\n      while (i < this._eventQueue.length) {\n        const { id, event } = this._eventQueue[i];\n        const offsetSec = event.time - currentTime;\n        const sampleIndex = offsetSec > 0 ? Math.round(offsetSec * sampleRate) : 0;\n        if (sampleIndex < this._samplesPerQuantum) {\n          if (eventsBySampleIndex[sampleIndex])\n            eventsBySampleIndex[sampleIndex].push(event);\n          else\n            eventsBySampleIndex[sampleIndex] = [event];\n          if (id)\n            this.port.postMessage({ id, response });\n          else if (this._eventSabReady)\n            this._eventWriter.write(event);\n          else\n            this.port.postMessage({ event });\n          this._eventQueue.shift();\n          i = -1;\n        } else\n          break;\n        i++;\n      }\n      const processingSlices = [];\n      const keys = Object.keys(eventsBySampleIndex);\n      if (keys[0] !== \"0\") {\n        keys.unshift(\"0\");\n        eventsBySampleIndex[\"0\"] = [];\n      }\n      const lastIndex = keys.length - 1;\n      i = 0;\n      while (i < keys.length) {\n        const key = keys[i];\n        const startSample = parseInt(key);\n        const endSample = i < lastIndex ? parseInt(keys[i + 1]) : this._samplesPerQuantum;\n        processingSlices.push({ range: [startSample, endSample], events: eventsBySampleIndex[key] });\n        i++;\n      }\n      return processingSlices;\n    }\n    _processEvent(event) {\n      switch (event.type) {\n        case \"wam-automation\":\n          this._setParameterValue(event.data, true);\n          break;\n        case \"wam-transport\":\n          this._onTransport(event.data);\n          break;\n        case \"wam-midi\":\n          this._onMidi(event.data);\n          break;\n        case \"wam-sysex\":\n          this._onSysex(event.data);\n          break;\n        case \"wam-mpe\":\n          this._onMpe(event.data);\n          break;\n        case \"wam-osc\":\n          this._onOsc(event.data);\n          break;\n        default:\n          break;\n      }\n    }\n    _process(startSample, endSample, inputs, outputs, parameters) {\n      console.error(\"_process not implemented!\");\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    if (!ModuleScope.WamProcessor)\n      ModuleScope.WamProcessor = WamProcessor;\n  }\n  return WamProcessor;\n};\nvar WamProcessor_default = getWamProcessor;\n\n// src/WamNode.js\nvar RingBuffer = RingBuffer_default();\nvar WamEventRingBuffer = WamEventRingBuffer_default();\nvar WamNode = class extends AudioWorkletNode {\n  static async addModules(audioContext, moduleId) {\n    const { audioWorklet } = audioContext;\n    await addFunctionModule_default(audioWorklet, RingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamEventRingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamArrayRingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameter_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameterInfo_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameterInterpolator_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamProcessor_default, moduleId);\n  }\n  constructor(module, options) {\n    const { audioContext, groupId, moduleId, instanceId } = module;\n    options.processorOptions = {\n      groupId,\n      moduleId,\n      instanceId,\n      ...options.processorOptions\n    };\n    super(audioContext, moduleId, options);\n    this.module = module;\n    this._supportedEventTypes = /* @__PURE__ */ new Set([\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\"]);\n    this._messageId = 1;\n    this._pendingResponses = {};\n    this._pendingEvents = {};\n    this._useSab = false;\n    this._eventSabReady = false;\n    this._destroyed = false;\n    this.port.onmessage = this._onMessage.bind(this);\n  }\n  get groupId() {\n    return this.module.groupId;\n  }\n  get moduleId() {\n    return this.module.moduleId;\n  }\n  get instanceId() {\n    return this.module.instanceId;\n  }\n  async getParameterInfo(...parameterIds) {\n    const request = \"get/parameterInfo\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { parameterIds }\n      });\n    });\n  }\n  async getParameterValues(normalized, ...parameterIds) {\n    const request = \"get/parameterValues\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { normalized, parameterIds }\n      });\n    });\n  }\n  async setParameterValues(parameterValues) {\n    const request = \"set/parameterValues\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { parameterValues }\n      });\n    });\n  }\n  async getState() {\n    const request = \"get/state\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  async setState(state) {\n    const request = \"set/state\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { state }\n      });\n    });\n  }\n  async getCompensationDelay() {\n    const request = \"get/compensationDelay\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  addEventListener(type, callback, options) {\n    if (this._supportedEventTypes.has(type))\n      super.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    if (this._supportedEventTypes.has(type))\n      super.removeEventListener(type, callback, options);\n  }\n  scheduleEvents(...events) {\n    let i = 0;\n    const numEvents = events.length;\n    if (this._eventSabReady) {\n      i = this._eventWriter.write(...events);\n    }\n    while (i < numEvents) {\n      const event = events[i];\n      const request = \"add/event\";\n      const id = this._generateMessageId();\n      let processed = false;\n      new Promise((resolve, reject) => {\n        this._pendingResponses[id] = resolve;\n        this._pendingEvents[id] = () => {\n          if (!processed)\n            reject();\n        };\n        this.port.postMessage({\n          id,\n          request,\n          content: { event }\n        });\n      }).then((resolved) => {\n        processed = true;\n        delete this._pendingEvents[id];\n        this._onEvent(event);\n      }).catch((rejected) => {\n        delete this._pendingResponses[id];\n      });\n      i++;\n    }\n  }\n  async clearEvents() {\n    const request = \"remove/events\";\n    const id = this._generateMessageId();\n    const ids = Object.keys(this._pendingEvents);\n    if (ids.length) {\n      return new Promise((resolve) => {\n        this._pendingResponses[id] = resolve;\n        this.port.postMessage({ id, request });\n      }).then((clearedIds) => {\n        clearedIds.forEach((clearedId) => {\n          this._pendingEvents[clearedId]();\n          delete this._pendingEvents[clearedId];\n        });\n      });\n    }\n  }\n  connectEvents(toId, output) {\n    const request = \"connect/events\";\n    const id = this._generateMessageId();\n    new Promise((resolve, reject) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { wamInstanceId: toId, output }\n      });\n    });\n  }\n  disconnectEvents(toId, output) {\n    const request = \"disconnect/events\";\n    const id = this._generateMessageId();\n    new Promise((resolve, reject) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { wamInstanceId: toId, output }\n      });\n    });\n  }\n  destroy() {\n    if (this._audioToMainInterval)\n      clearInterval(this._audioToMainInterval);\n    this.port.postMessage({ destroy: true });\n    this.port.close();\n    this.disconnect();\n    this._destroyed = true;\n  }\n  _generateMessageId() {\n    return this._messageId++;\n  }\n  async _initialize() {\n    const request = \"initialize/processor\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  _onMessage(message) {\n    const { data } = message;\n    const { response, event, eventSab } = data;\n    if (response) {\n      const { id, content } = data;\n      const resolvePendingResponse = this._pendingResponses[id];\n      if (resolvePendingResponse) {\n        delete this._pendingResponses[id];\n        resolvePendingResponse(content);\n      }\n    } else if (eventSab) {\n      this._useSab = true;\n      const { eventCapacity, parameterIds } = eventSab;\n      if (this._eventSabReady) {\n        this._eventWriter.setParameterIds(parameterIds);\n        this._eventReader.setParameterIds(parameterIds);\n        return;\n      }\n      this._mainToAudioEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n      this._audioToMainEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n      this._eventWriter = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab, parameterIds);\n      this._eventReader = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab, parameterIds);\n      const request = \"initialize/eventSab\";\n      const id = this._generateMessageId();\n      new Promise((resolve, reject) => {\n        this._pendingResponses[id] = resolve;\n        this.port.postMessage({\n          id,\n          request,\n          content: {\n            mainToAudioEventSab: this._mainToAudioEventSab,\n            audioToMainEventSab: this._audioToMainEventSab\n          }\n        });\n      }).then((resolved) => {\n        this._eventSabReady = true;\n        this._audioToMainInterval = setInterval(() => {\n          const events = this._eventReader.read();\n          events.forEach((e) => {\n            this._onEvent(e);\n          });\n        }, 100);\n      });\n    } else if (event)\n      this._onEvent(event);\n  }\n  _onEvent(event) {\n    const { type } = event;\n    this.dispatchEvent(new CustomEvent(type, {\n      bubbles: true,\n      detail: event\n    }));\n  }\n};\n\n// src/apiVersion.js\nvar apiVersion_default = \"2.0.0-alpha.4\";\n\n// src/initializeWamHost.js\nvar initializeWamHost = async (audioContext, hostGroupId = `wam-host-${performance.now().toString()}`, hostGroupKey = performance.now().toString()) => {\n  await addFunctionModule_default(audioContext.audioWorklet, WamEnv_default, apiVersion_default);\n  await addFunctionModule_default(audioContext.audioWorklet, WamGroup_default, hostGroupId, hostGroupKey);\n  return [hostGroupId, hostGroupKey];\n};\nvar initializeWamHost_default = initializeWamHost;\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://soundfont-wam/../../../node_modules/@webaudiomodules/sdk/dist/index.js?");

/***/ }),

/***/ "../../../node_modules/preact/dist/preact.module.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/preact/dist/preact.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ S),\n/* harmony export */   \"hydrate\": () => (/* binding */ q),\n/* harmony export */   \"createElement\": () => (/* binding */ v),\n/* harmony export */   \"h\": () => (/* binding */ v),\n/* harmony export */   \"Fragment\": () => (/* binding */ d),\n/* harmony export */   \"createRef\": () => (/* binding */ p),\n/* harmony export */   \"isValidElement\": () => (/* binding */ i),\n/* harmony export */   \"Component\": () => (/* binding */ _),\n/* harmony export */   \"cloneElement\": () => (/* binding */ B),\n/* harmony export */   \"createContext\": () => (/* binding */ D),\n/* harmony export */   \"toChildArray\": () => (/* binding */ A),\n/* harmony export */   \"options\": () => (/* binding */ l)\n/* harmony export */ });\nvar n,l,u,i,t,o,r,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(l,u,i){var t,o,r,f={};for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return y(l,f,t,o,null)}function y(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u:r};return null!=l.vnode&&l.vnode(f),f}function p(){return{current:null}}function d(n){return n.children}function _(n,l){this.props=n,this.context=l}function k(n,l){if(null==l)return n.__?k(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?k(n):null}function b(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return b(n)}}function m(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g.__r++||r!==l.debounceRendering)&&((r=l.debounceRendering)||o)(g)}function g(){for(var n;g.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=a({},t)).__v=t.__v+1,j(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?k(t):o,t.__h),z(u,t),t.__e!=o&&b(t)))})}function w(n,l,u,i,t,o,r,f,s,a){var h,v,p,_,b,m,g,w=i&&i.__k||c,A=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(_=u.__k[h]=null==(_=l[h])||\"boolean\"==typeof _?null:\"string\"==typeof _||\"number\"==typeof _||\"bigint\"==typeof _?y(null,_,null,null,_):Array.isArray(_)?y(d,{children:_},null,null,null):_.__b>0?y(_.type,_.props,_.key,null,_.__v):_)){if(_.__=u,_.__b=u.__b+1,null===(p=w[h])||p&&_.key==p.key&&_.type===p.type)w[h]=void 0;else for(v=0;v<A;v++){if((p=w[v])&&_.key==p.key&&_.type===p.type){w[v]=void 0;break}p=null}j(n,_,p=p||e,t,o,r,f,s,a),b=_.__e,(v=_.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,_),g.push(v,_.__c||b,_)),null!=b?(null==m&&(m=b),\"function\"==typeof _.type&&null!=_.__k&&_.__k===p.__k?_.__d=s=x(_,s,n):s=P(n,_,p,w,b,s),a||\"option\"!==u.type?\"function\"==typeof u.type&&(u.__d=s):n.value=\"\"):s&&p.__e==s&&s.parentNode!=n&&(s=k(p))}for(u.__e=m,h=A;h--;)null!=w[h]&&(\"function\"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=k(i,h+1)),N(w[h],w[h]));if(g)for(h=0;h<g.length;h++)M(g[h],g[++h],g[++h])}function x(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,l=\"function\"==typeof t.type?x(t,l,u):P(u,t,t,n.__k,t.__e,l));return l}function A(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(Array.isArray(n)?n.some(function(n){A(n,l)}):l.push(n)),l}function P(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else{for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o}return void 0!==r?r:t.nextSibling}function C(n,l,u,i,t){var o;for(o in u)\"children\"===o||\"key\"===o||o in l||H(n,o,null,u[o],i);for(o in l)t&&\"function\"!=typeof l[o]||\"children\"===o||\"key\"===o||\"value\"===o||\"checked\"===o||u[o]===l[o]||H(n,o,l[o],u[o],i)}function $(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=null==u?\"\":\"number\"!=typeof u||s.test(l)?u:u+\"px\"}function H(n,l,u,i,t){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof i&&(n.style.cssText=i=\"\"),i)for(l in i)u&&l in u||$(n.style,l,\"\");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/Capture$/,\"\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T:I,o):n.removeEventListener(l,o?T:I,o);else if(\"dangerouslySetInnerHTML\"!==l){if(t)l=l.replace(/xlink[H:h]/,\"h\").replace(/sName$/,\"s\");else if(\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null!=u&&(!1!==u||\"a\"===l[0]&&\"r\"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function I(n){this.l[n.type+!1](l.event?l.event(n):n)}function T(n){this.l[n.type+!0](l.event?l.event(n):n)}function j(n,u,i,t,o,r,f,e,c){var s,h,v,y,p,k,b,m,g,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(s=l.__b)&&s(u);try{n:if(\"function\"==typeof P){if(m=u.props,g=(s=P.contextType)&&t[s.__c],x=s?g?g.props.value:s.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:(\"prototype\"in P&&P.prototype.render?u.__c=h=new P(m,x):(u.__c=h=new _(m,x),h.constructor=P,h.render=O),g&&g.sub(h),h.props=m,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=a({},h.__s)),a(h.__s,P.getDerivedStateFromProps(m,h.__s))),y=h.props,p=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,x)||u.__v===i.__v){h.props=m,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,p,k)})}h.context=x,h.props=m,h.state=h.__s,(s=l.__r)&&s(u),h.__d=!1,h.__v=u,h.__P=n,s=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=a(a({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,p)),A=null!=s&&s.type===d&&null==s.key?s.props.children:s,w(n,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,o,r,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l.__e(n,u,i)}}function z(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function L(l,u,i,t,o,r,f,c){var s,a,v,y=i.props,p=u.props,d=u.type,_=0;if(\"svg\"===d&&(o=!0),null!=r)for(;_<r.length;_++)if((s=r[_])&&(s===l||(d?s.localName==d:3==s.nodeType))){l=s,r[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS(\"http://www.w3.org/2000/svg\",d):document.createElement(d,p.is&&p),r=null,c=!1}if(null===d)y===p||c&&l.data===p||(l.data=p);else{if(r=r&&n.call(l.childNodes),a=(y=i.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(v||a)&&(v&&(a&&v.__html==a.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||\"\"))}if(C(l,p,y,o,c),v)u.__k=[];else if(_=u.props.children,w(l,Array.isArray(_)?_:[_],u,i,t,o&&\"foreignObject\"!==d,r,f,r?r[0]:i.__k&&k(i,0),c),null!=r)for(_=r.length;_--;)null!=r[_]&&h(r[_]);c||(\"value\"in p&&void 0!==(_=p.value)&&(_!==l.value||\"progress\"===d&&!_)&&H(l,\"value\",_,y.value,!1),\"checked\"in p&&void 0!==(_=p.checked)&&_!==l.checked&&H(l,\"checked\",_,y.checked,!1))}return l}function M(n,u,i){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function N(n,u,i){var t,o;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,\"function\"!=typeof n.type);i||null==n.__e||h(n.__e),n.__e=n.__d=void 0}function O(n,l,u){return this.constructor(n,u)}function S(u,i,t){var o,r,f;l.__&&l.__(u,i),r=(o=\"function\"==typeof t)?null:t&&t.__k||i.__k,f=[],j(i,u=(!o&&t||i).__k=v(d,null,[u]),r||e,e,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,f,!o&&t?t:r?r.__e:i.firstChild,o),z(f,u)}function q(n,l){S(n,l,q)}function B(l,u,i){var t,o,r,f=a({},l.props);for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),y(l.type,f,t||l.key,o||l.ref,null)}function D(n,l){var u={__c:l=\"__cC\"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(m)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=c.slice,l={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l}throw n}},u=0,i=function(n){return null!=n&&void 0===n.constructor},_.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),\"function\"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),m(this))},_.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m(this))},_.prototype.render=d,t=[],o=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,f=0;\n//# sourceMappingURL=preact.module.js.map\n\n\n//# sourceURL=webpack://soundfont-wam/../../../node_modules/preact/dist/preact.module.js?");

/***/ }),

/***/ "./node_modules/adsr/index.js":
/*!************************************!*\
  !*** ./node_modules/adsr/index.js ***!
  \************************************/
/***/ ((module) => {

eval("module.exports = ADSR\n\nfunction ADSR(audioContext){\n  var node = audioContext.createGain()\n\n  var voltage = node._voltage = getVoltage(audioContext)\n  var value = scale(voltage)\n  var startValue = scale(voltage)\n  var endValue = scale(voltage)\n\n  node._startAmount = scale(startValue)\n  node._endAmount = scale(endValue)\n\n  node._multiplier = scale(value)\n  node._multiplier.connect(node)\n  node._startAmount.connect(node)\n  node._endAmount.connect(node)\n\n  node.value = value.gain\n  node.startValue = startValue.gain\n  node.endValue = endValue.gain\n\n  node.startValue.value = 0\n  node.endValue.value = 0\n\n  Object.defineProperties(node, props)\n  return node\n}\n\nvar props = {\n\n  attack: { value: 0, writable: true },\n  decay: { value: 0, writable: true },\n  sustain: { value: 1, writable: true },\n  release: {value: 0, writable: true },\n\n  getReleaseDuration: {\n    value: function(){\n      return this.release\n    }\n  },\n\n  start: {\n    value: function(at){\n      var target = this._multiplier.gain\n      var startAmount = this._startAmount.gain\n      var endAmount = this._endAmount.gain\n\n      this._voltage.start(at)\n      this._decayFrom = this._decayFrom = at+this.attack\n      this._startedAt = at\n\n      var sustain = this.sustain\n\n      target.cancelScheduledValues(at)\n      startAmount.cancelScheduledValues(at)\n      endAmount.cancelScheduledValues(at)\n\n      endAmount.setValueAtTime(0, at)\n\n      if (this.attack){\n        target.setValueAtTime(0, at)\n        target.linearRampToValueAtTime(1, at + this.attack)\n\n        startAmount.setValueAtTime(1, at)\n        startAmount.linearRampToValueAtTime(0, at + this.attack)\n      } else {\n        target.setValueAtTime(1, at)\n        startAmount.setValueAtTime(0, at)\n      }\n\n      if (this.decay){\n        target.setTargetAtTime(sustain, this._decayFrom, getTimeConstant(this.decay))\n      }\n    }\n  },\n\n  stop: {\n    value: function(at, isTarget){\n      if (isTarget){\n        at = at - this.release\n      }\n\n      var endTime = at + this.release\n      if (this.release){\n\n        var target = this._multiplier.gain\n        var startAmount = this._startAmount.gain\n        var endAmount = this._endAmount.gain\n\n        target.cancelScheduledValues(at)\n        startAmount.cancelScheduledValues(at)\n        endAmount.cancelScheduledValues(at)\n\n        var expFalloff = getTimeConstant(this.release)\n\n        // truncate attack (required as linearRamp is removed by cancelScheduledValues)\n        if (this.attack && at < this._decayFrom){\n          var valueAtTime = getValue(0, 1, this._startedAt, this._decayFrom, at)\n          target.linearRampToValueAtTime(valueAtTime, at)\n          startAmount.linearRampToValueAtTime(1-valueAtTime, at)\n          startAmount.setTargetAtTime(0, at, expFalloff)\n        }\n\n        endAmount.setTargetAtTime(1, at, expFalloff)\n        target.setTargetAtTime(0, at, expFalloff)\n      }\n\n      this._voltage.stop(endTime)\n      return endTime\n    }\n  },\n\n  onended: {\n    get: function(){\n      return this._voltage.onended\n    },\n    set: function(value){\n      this._voltage.onended = value\n    }\n  }\n\n}\n\nvar flat = new Float32Array([1,1])\nfunction getVoltage(context){\n  var voltage = context.createBufferSource()\n  var buffer = context.createBuffer(1, 2, context.sampleRate)\n  buffer.getChannelData(0).set(flat)\n  voltage.buffer = buffer\n  voltage.loop = true\n  return voltage\n}\n\nfunction scale(node){\n  var gain = node.context.createGain()\n  node.connect(gain)\n  return gain\n}\n\nfunction getTimeConstant(time){\n  return Math.log(time+1)/Math.log(100)\n}\n\nfunction getValue(start, end, fromTime, toTime, at){\n  var difference = end - start\n  var time = toTime - fromTime\n  var truncateTime = at - fromTime\n  var phase = truncateTime / time\n  var value = start + phase * difference\n\n  if (value <= start) {\n      value = start\n  }\n  if (value >= end) {\n      value = end\n  }\n\n  return value\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/adsr/index.js?");

/***/ }),

/***/ "./node_modules/audio-loader/lib/base64.js":
/*!*************************************************!*\
  !*** ./node_modules/audio-loader/lib/base64.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// DECODE UTILITIES\nfunction b64ToUint6 (nChr) {\n  return nChr > 64 && nChr < 91 ? nChr - 65\n    : nChr > 96 && nChr < 123 ? nChr - 71\n    : nChr > 47 && nChr < 58 ? nChr + 4\n    : nChr === 43 ? 62\n    : nChr === 47 ? 63\n    : 0\n}\n\n// Decode Base64 to Uint8Array\n// ---------------------------\nfunction decode (sBase64, nBlocksSize) {\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9\\+\\/]/g, '')\n  var nInLen = sB64Enc.length\n  var nOutLen = nBlocksSize\n    ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize\n    : nInLen * 3 + 1 >> 2\n  var taBytes = new Uint8Array(nOutLen)\n\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n    nMod4 = nInIdx & 3\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255\n      }\n      nUint24 = 0\n    }\n  }\n  return taBytes\n}\n\nmodule.exports = { decode: decode }\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/audio-loader/lib/base64.js?");

/***/ }),

/***/ "./node_modules/audio-loader/lib/fetch.js":
/*!************************************************!*\
  !*** ./node_modules/audio-loader/lib/fetch.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/* global XMLHttpRequest */\n\n\n/**\n * Given a url and a return type, returns a promise to the content of the url\n * Basically it wraps a XMLHttpRequest into a Promise\n *\n * @param {String} url\n * @param {String} type - can be 'text' or 'arraybuffer'\n * @return {Promise}\n */\nmodule.exports = function (url, type) {\n  return new Promise(function (done, reject) {\n    var req = new XMLHttpRequest()\n    if (type) req.responseType = type\n\n    req.open('GET', url)\n    req.onload = function () {\n      req.status === 200 ? done(req.response) : reject(Error(req.statusText))\n    }\n    req.onerror = function () { reject(Error('Network Error')) }\n    req.send()\n  })\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/audio-loader/lib/fetch.js?");

/***/ }),

/***/ "./node_modules/audio-loader/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/audio-loader/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar base64 = __webpack_require__(/*! ./base64 */ \"./node_modules/audio-loader/lib/base64.js\")\nvar fetch = __webpack_require__(/*! ./fetch */ \"./node_modules/audio-loader/lib/fetch.js\")\n\n// Given a regex, return a function that test if against a string\nfunction fromRegex (r) {\n  return function (o) { return typeof o === 'string' && r.test(o) }\n}\n// Try to apply a prefix to a name\nfunction prefix (pre, name) {\n  return typeof pre === 'string' ? pre + name\n    : typeof pre === 'function' ? pre(name)\n    : name\n}\n\n/**\n * Load one or more audio files\n *\n *\n * Possible option keys:\n *\n * - __from__ {Function|String}: a function or string to convert from file names to urls.\n * If is a string it will be prefixed to the name:\n * `load(ac, 'snare.mp3', { from: 'http://audio.net/samples/' })`\n * If it's a function it receives the file name and should return the url as string.\n * - __only__ {Array} - when loading objects, if provided, only the given keys\n * will be included in the decoded object:\n * `load(ac, 'piano.json', { only: ['C2', 'D2'] })`\n *\n * @param {AudioContext} ac - the audio context\n * @param {Object} source - the object to be loaded\n * @param {Object} options - (Optional) the load options for that object\n * @param {Object} defaultValue - (Optional) the default value to return as\n * in a promise if not valid loader found\n */\nfunction load (ac, source, options, defVal) {\n  var loader =\n    // Basic audio loading\n      isArrayBuffer(source) ? loadArrayBuffer\n    : isAudioFileName(source) ? loadAudioFile\n    : isPromise(source) ? loadPromise\n    // Compound objects\n    : isArray(source) ? loadArrayData\n    : isObject(source) ? loadObjectData\n    : isJsonFileName(source) ? loadJsonFile\n    // Base64 encoded audio\n    : isBase64Audio(source) ? loadBase64Audio\n    : isJsFileName(source) ? loadMidiJSFile\n    : null\n\n  var opts = options || {}\n  return loader ? loader(ac, source, opts)\n    : defVal ? Promise.resolve(defVal)\n    : Promise.reject('Source not valid (' + source + ')')\n}\nload.fetch = fetch\n\n// BASIC AUDIO LOADING\n// ===================\n\n// Load (decode) an array buffer\nfunction isArrayBuffer (o) { return o instanceof ArrayBuffer }\nfunction loadArrayBuffer (ac, array, options) {\n  return new Promise(function (done, reject) {\n    ac.decodeAudioData(array,\n      function (buffer) { done(buffer) },\n      function () { reject(\"Can't decode audio data (\" + array.slice(0, 30) + '...)') }\n    )\n  })\n}\n\n// Load an audio filename\nvar isAudioFileName = fromRegex(/\\.(mp3|wav|ogg)(\\?.*)?$/i)\nfunction loadAudioFile (ac, name, options) {\n  var url = prefix(options.from, name)\n  return load(ac, load.fetch(url, 'arraybuffer'), options)\n}\n\n// Load the result of a promise\nfunction isPromise (o) { return o && typeof o.then === 'function' }\nfunction loadPromise (ac, promise, options) {\n  return promise.then(function (value) {\n    return load(ac, value, options)\n  })\n}\n\n// COMPOUND OBJECTS\n// ================\n\n// Try to load all the items of an array\nvar isArray = Array.isArray\nfunction loadArrayData (ac, array, options) {\n  return Promise.all(array.map(function (data) {\n    return load(ac, data, options, data)\n  }))\n}\n\n// Try to load all the values of a key/value object\nfunction isObject (o) { return o && typeof o === 'object' }\nfunction loadObjectData (ac, obj, options) {\n  var dest = {}\n  var promises = Object.keys(obj).map(function (key) {\n    if (options.only && options.only.indexOf(key) === -1) return null\n    var value = obj[key]\n    return load(ac, value, options, value).then(function (audio) {\n      dest[key] = audio\n    })\n  })\n  return Promise.all(promises).then(function () { return dest })\n}\n\n// Load the content of a JSON file\nvar isJsonFileName = fromRegex(/\\.json(\\?.*)?$/i)\nfunction loadJsonFile (ac, name, options) {\n  var url = prefix(options.from, name)\n  return load(ac, load.fetch(url, 'text').then(JSON.parse), options)\n}\n\n// BASE64 ENCODED FORMATS\n// ======================\n\n// Load strings with Base64 encoded audio\nvar isBase64Audio = fromRegex(/^data:audio/)\nfunction loadBase64Audio (ac, source, options) {\n  var i = source.indexOf(',')\n  return load(ac, base64.decode(source.slice(i + 1)).buffer, options)\n}\n\n// Load .js files with MidiJS soundfont prerendered audio\nvar isJsFileName = fromRegex(/\\.js(\\?.*)?$/i)\nfunction loadMidiJSFile (ac, name, options) {\n  var url = prefix(options.from, name)\n  return load(ac, load.fetch(url, 'text').then(midiJsToJson), options)\n}\n\n// convert a MIDI.js javascript soundfont file to json\nfunction midiJsToJson (data) {\n  var begin = data.indexOf('MIDI.Soundfont.')\n  if (begin < 0) throw Error('Invalid MIDI.js Soundfont format')\n  begin = data.indexOf('=', begin) + 2\n  var end = data.lastIndexOf(',')\n  return JSON.parse(data.slice(begin, end) + '}')\n}\n\nif ( true && module.exports) module.exports = load\nif (typeof window !== 'undefined') window.loadAudio = load\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/audio-loader/lib/index.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/SoundfontView.scss":
/*!********************************!*\
  !*** ./src/SoundfontView.scss ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".ComponentWrapper {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  text-align: center;\\n  flex: 1;\\n  padding: 4px;\\n}\\n\\n.Fader {\\n  margin-top: auto;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.Knob {\\n  margin-top: auto;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.ComponentSelect {\\n  margin-bottom: auto;\\n  margin-top: auto;\\n  margin-bottom: auto;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.GlowModalBackdrop {\\n  position: fixed;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n  background-color: rgba(0, 0, 0, 0.3);\\n  padding: 50px;\\n  z-index: 99999998;\\n}\\n\\n.GlowModalContainer {\\n  position: fixed;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n  margin: 0 auto;\\n  z-index: 99999998;\\n}\\n\\n.nbPWZwipzoqg5B92YbCm {\\n  flex: 1;\\n  background-color: #292a30;\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: space-between;\\n  padding: 10px;\\n  color: white;\\n}\\n\\n.M18k4HOZoaKdrv9CQMkg {\\n  /* border: 1px solid white; */\\n  border: 1px solid rgba(0, 0, 0, 0.3);\\n  border-radius: 2px;\\n  margin: 5px;\\n  display: flex;\\n  flex-direction: column;\\n}\", \"\"]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"module\": \"nbPWZwipzoqg5B92YbCm\",\n\t\"section\": \"M18k4HOZoaKdrv9CQMkg\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://soundfont-wam/./src/SoundfontView.scss?");

/***/ }),

/***/ "./node_modules/midimessage/dist/index.min.js":
/*!****************************************************!*\
  !*** ./node_modules/midimessage/dist/index.min.js ***!
  \****************************************************/
/***/ ((module) => {

eval("(function(e){if(true){module.exports=e()}else { var t; }})(function(){var e,t,s;return function o(e,t,s){function a(n,i){if(!t[n]){if(!e[n]){var l=undefined;if(!i&&l)return require(n,!0);if(r)return r(n,!0);var h=new Error(\"Cannot find module '\"+n+\"'\");throw h.code=\"MODULE_NOT_FOUND\",h}var c=t[n]={exports:{}};e[n][0].call(c.exports,function(t){var s=e[n][1][t];return a(s?s:t)},c,c.exports,o,e,t,s)}return t[n].exports}var r=undefined;for(var n=0;n<s.length;n++)a(s[n]);return a}({1:[function(e,t,s){\"use strict\";Object.defineProperty(s,\"__esModule\",{value:true});s[\"default\"]=function(e){function t(e){this._event=e;this._data=e.data;this.receivedTime=e.receivedTime;if(this._data&&this._data.length<2){console.warn(\"Illegal MIDI message of length\",this._data.length);return}this._messageCode=e.data[0]&240;this.channel=e.data[0]&15;switch(this._messageCode){case 128:this.messageType=\"noteoff\";this.key=e.data[1]&127;this.velocity=e.data[2]&127;break;case 144:this.messageType=\"noteon\";this.key=e.data[1]&127;this.velocity=e.data[2]&127;break;case 160:this.messageType=\"keypressure\";this.key=e.data[1]&127;this.pressure=e.data[2]&127;break;case 176:this.messageType=\"controlchange\";this.controllerNumber=e.data[1]&127;this.controllerValue=e.data[2]&127;if(this.controllerNumber===120&&this.controllerValue===0){this.channelModeMessage=\"allsoundoff\"}else if(this.controllerNumber===121){this.channelModeMessage=\"resetallcontrollers\"}else if(this.controllerNumber===122){if(this.controllerValue===0){this.channelModeMessage=\"localcontroloff\"}else{this.channelModeMessage=\"localcontrolon\"}}else if(this.controllerNumber===123&&this.controllerValue===0){this.channelModeMessage=\"allnotesoff\"}else if(this.controllerNumber===124&&this.controllerValue===0){this.channelModeMessage=\"omnimodeoff\"}else if(this.controllerNumber===125&&this.controllerValue===0){this.channelModeMessage=\"omnimodeon\"}else if(this.controllerNumber===126){this.channelModeMessage=\"monomodeon\"}else if(this.controllerNumber===127){this.channelModeMessage=\"polymodeon\"}break;case 192:this.messageType=\"programchange\";this.program=e.data[1];break;case 208:this.messageType=\"channelpressure\";this.pressure=e.data[1]&127;break;case 224:this.messageType=\"pitchbendchange\";var t=e.data[2]&127;var s=e.data[1]&127;this.pitchBend=(t<<8)+s;break}}return new t(e)};t.exports=s[\"default\"]},{}]},{},[1])(1)});\n//# sourceMappingURL=dist/index.js.map\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/midimessage/dist/index.min.js?");

/***/ }),

/***/ "./node_modules/note-parser/index.js":
/*!*******************************************!*\
  !*** ./node_modules/note-parser/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"regex\": () => (/* binding */ regex),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"build\": () => (/* binding */ build),\n/* harmony export */   \"midi\": () => (/* binding */ midi),\n/* harmony export */   \"freq\": () => (/* binding */ freq),\n/* harmony export */   \"letter\": () => (/* binding */ letter),\n/* harmony export */   \"acc\": () => (/* binding */ acc),\n/* harmony export */   \"pc\": () => (/* binding */ pc),\n/* harmony export */   \"step\": () => (/* binding */ step),\n/* harmony export */   \"alt\": () => (/* binding */ alt),\n/* harmony export */   \"chroma\": () => (/* binding */ chroma),\n/* harmony export */   \"oct\": () => (/* binding */ oct)\n/* harmony export */ });\n\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nfunction regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nfunction parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nfunction build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nfunction midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nfunction freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nfunction letter (src) { return (parse(src) || {}).letter }\nfunction acc (src) { return (parse(src) || {}).acc }\nfunction pc (src) { return (parse(src) || {}).pc }\nfunction step (src) { return (parse(src) || {}).step }\nfunction alt (src) { return (parse(src) || {}).alt }\nfunction chroma (src) { return (parse(src) || {}).chroma }\nfunction oct (src) { return (parse(src) || {}).oct }\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/note-parser/index.js?");

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ S),\n/* harmony export */   \"hydrate\": () => (/* binding */ q),\n/* harmony export */   \"createElement\": () => (/* binding */ v),\n/* harmony export */   \"h\": () => (/* binding */ v),\n/* harmony export */   \"Fragment\": () => (/* binding */ d),\n/* harmony export */   \"createRef\": () => (/* binding */ p),\n/* harmony export */   \"isValidElement\": () => (/* binding */ i),\n/* harmony export */   \"Component\": () => (/* binding */ _),\n/* harmony export */   \"cloneElement\": () => (/* binding */ B),\n/* harmony export */   \"createContext\": () => (/* binding */ D),\n/* harmony export */   \"toChildArray\": () => (/* binding */ A),\n/* harmony export */   \"options\": () => (/* binding */ l)\n/* harmony export */ });\nvar n,l,u,i,t,o,r,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(l,u,i){var t,o,r,f={};for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return y(l,f,t,o,null)}function y(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u:r};return null!=l.vnode&&l.vnode(f),f}function p(){return{current:null}}function d(n){return n.children}function _(n,l){this.props=n,this.context=l}function k(n,l){if(null==l)return n.__?k(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?k(n):null}function b(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return b(n)}}function m(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g.__r++||r!==l.debounceRendering)&&((r=l.debounceRendering)||o)(g)}function g(){for(var n;g.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=a({},t)).__v=t.__v+1,j(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?k(t):o,t.__h),z(u,t),t.__e!=o&&b(t)))})}function w(n,l,u,i,t,o,r,f,s,a){var h,v,p,_,b,m,g,w=i&&i.__k||c,A=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(_=u.__k[h]=null==(_=l[h])||\"boolean\"==typeof _?null:\"string\"==typeof _||\"number\"==typeof _||\"bigint\"==typeof _?y(null,_,null,null,_):Array.isArray(_)?y(d,{children:_},null,null,null):_.__b>0?y(_.type,_.props,_.key,null,_.__v):_)){if(_.__=u,_.__b=u.__b+1,null===(p=w[h])||p&&_.key==p.key&&_.type===p.type)w[h]=void 0;else for(v=0;v<A;v++){if((p=w[v])&&_.key==p.key&&_.type===p.type){w[v]=void 0;break}p=null}j(n,_,p=p||e,t,o,r,f,s,a),b=_.__e,(v=_.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,_),g.push(v,_.__c||b,_)),null!=b?(null==m&&(m=b),\"function\"==typeof _.type&&null!=_.__k&&_.__k===p.__k?_.__d=s=x(_,s,n):s=P(n,_,p,w,b,s),a||\"option\"!==u.type?\"function\"==typeof u.type&&(u.__d=s):n.value=\"\"):s&&p.__e==s&&s.parentNode!=n&&(s=k(p))}for(u.__e=m,h=A;h--;)null!=w[h]&&(\"function\"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=k(i,h+1)),N(w[h],w[h]));if(g)for(h=0;h<g.length;h++)M(g[h],g[++h],g[++h])}function x(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,l=\"function\"==typeof t.type?x(t,l,u):P(u,t,t,n.__k,t.__e,l));return l}function A(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(Array.isArray(n)?n.some(function(n){A(n,l)}):l.push(n)),l}function P(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else{for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o}return void 0!==r?r:t.nextSibling}function C(n,l,u,i,t){var o;for(o in u)\"children\"===o||\"key\"===o||o in l||H(n,o,null,u[o],i);for(o in l)t&&\"function\"!=typeof l[o]||\"children\"===o||\"key\"===o||\"value\"===o||\"checked\"===o||u[o]===l[o]||H(n,o,l[o],u[o],i)}function $(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=null==u?\"\":\"number\"!=typeof u||s.test(l)?u:u+\"px\"}function H(n,l,u,i,t){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof i&&(n.style.cssText=i=\"\"),i)for(l in i)u&&l in u||$(n.style,l,\"\");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/Capture$/,\"\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T:I,o):n.removeEventListener(l,o?T:I,o);else if(\"dangerouslySetInnerHTML\"!==l){if(t)l=l.replace(/xlink[H:h]/,\"h\").replace(/sName$/,\"s\");else if(\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null!=u&&(!1!==u||\"a\"===l[0]&&\"r\"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function I(n){this.l[n.type+!1](l.event?l.event(n):n)}function T(n){this.l[n.type+!0](l.event?l.event(n):n)}function j(n,u,i,t,o,r,f,e,c){var s,h,v,y,p,k,b,m,g,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(s=l.__b)&&s(u);try{n:if(\"function\"==typeof P){if(m=u.props,g=(s=P.contextType)&&t[s.__c],x=s?g?g.props.value:s.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:(\"prototype\"in P&&P.prototype.render?u.__c=h=new P(m,x):(u.__c=h=new _(m,x),h.constructor=P,h.render=O),g&&g.sub(h),h.props=m,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=a({},h.__s)),a(h.__s,P.getDerivedStateFromProps(m,h.__s))),y=h.props,p=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,x)||u.__v===i.__v){h.props=m,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,p,k)})}h.context=x,h.props=m,h.state=h.__s,(s=l.__r)&&s(u),h.__d=!1,h.__v=u,h.__P=n,s=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=a(a({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,p)),A=null!=s&&s.type===d&&null==s.key?s.props.children:s,w(n,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,o,r,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l.__e(n,u,i)}}function z(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function L(l,u,i,t,o,r,f,c){var s,a,v,y=i.props,p=u.props,d=u.type,_=0;if(\"svg\"===d&&(o=!0),null!=r)for(;_<r.length;_++)if((s=r[_])&&(s===l||(d?s.localName==d:3==s.nodeType))){l=s,r[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS(\"http://www.w3.org/2000/svg\",d):document.createElement(d,p.is&&p),r=null,c=!1}if(null===d)y===p||c&&l.data===p||(l.data=p);else{if(r=r&&n.call(l.childNodes),a=(y=i.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(v||a)&&(v&&(a&&v.__html==a.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||\"\"))}if(C(l,p,y,o,c),v)u.__k=[];else if(_=u.props.children,w(l,Array.isArray(_)?_:[_],u,i,t,o&&\"foreignObject\"!==d,r,f,r?r[0]:i.__k&&k(i,0),c),null!=r)for(_=r.length;_--;)null!=r[_]&&h(r[_]);c||(\"value\"in p&&void 0!==(_=p.value)&&(_!==l.value||\"progress\"===d&&!_)&&H(l,\"value\",_,y.value,!1),\"checked\"in p&&void 0!==(_=p.checked)&&_!==l.checked&&H(l,\"checked\",_,y.checked,!1))}return l}function M(n,u,i){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function N(n,u,i){var t,o;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,\"function\"!=typeof n.type);i||null==n.__e||h(n.__e),n.__e=n.__d=void 0}function O(n,l,u){return this.constructor(n,u)}function S(u,i,t){var o,r,f;l.__&&l.__(u,i),r=(o=\"function\"==typeof t)?null:t&&t.__k||i.__k,f=[],j(i,u=(!o&&t||i).__k=v(d,null,[u]),r||e,e,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,f,!o&&t?t:r?r.__e:i.firstChild,o),z(f,u)}function q(n,l){S(n,l,q)}function B(l,u,i){var t,o,r,f=a({},l.props);for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),y(l.type,f,t||l.key,o||l.ref,null)}function D(n,l){var u={__c:l=\"__cC\"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(m)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=c.slice,l={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l}throw n}},u=0,i=function(n){return null!=n&&void 0===n.constructor},_.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),\"function\"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),m(this))},_.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m(this))},_.prototype.render=d,t=[],o=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,f=0;\n//# sourceMappingURL=preact.module.js.map\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/preact/dist/preact.module.js?");

/***/ }),

/***/ "./node_modules/sample-player/lib/events.js":
/*!**************************************************!*\
  !*** ./node_modules/sample-player/lib/events.js ***!
  \**************************************************/
/***/ ((module) => {

eval("\nmodule.exports = function (player) {\n  /**\n   * Adds a listener of an event\n   * @chainable\n   * @param {String} event - the event name\n   * @param {Function} callback - the event handler\n   * @return {SamplePlayer} the player\n   * @example\n   * player.on('start', function(time, note) {\n   *   console.log(time, note)\n   * })\n   */\n  player.on = function (event, cb) {\n    if (arguments.length === 1 && typeof event === 'function') return player.on('event', event)\n    var prop = 'on' + event\n    var old = player[prop]\n    player[prop] = old ? chain(old, cb) : cb\n    return player\n  }\n  return player\n}\n\nfunction chain (fn1, fn2) {\n  return function (a, b, c, d) { fn1(a, b, c, d); fn2(a, b, c, d) }\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/sample-player/lib/events.js?");

/***/ }),

/***/ "./node_modules/sample-player/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sample-player/lib/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar player = __webpack_require__(/*! ./player */ \"./node_modules/sample-player/lib/player.js\")\nvar events = __webpack_require__(/*! ./events */ \"./node_modules/sample-player/lib/events.js\")\nvar notes = __webpack_require__(/*! ./notes */ \"./node_modules/sample-player/lib/notes.js\")\nvar scheduler = __webpack_require__(/*! ./scheduler */ \"./node_modules/sample-player/lib/scheduler.js\")\nvar midi = __webpack_require__(/*! ./midi */ \"./node_modules/sample-player/lib/midi.js\")\n\nfunction SamplePlayer (ac, source, options) {\n  return midi(scheduler(notes(events(player(ac, source, options)))))\n}\n\nif ( true && module.exports) module.exports = SamplePlayer\nif (typeof window !== 'undefined') window.SamplePlayer = SamplePlayer\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/sample-player/lib/index.js?");

/***/ }),

/***/ "./node_modules/sample-player/lib/midi.js":
/*!************************************************!*\
  !*** ./node_modules/sample-player/lib/midi.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var midimessage = __webpack_require__(/*! midimessage */ \"./node_modules/midimessage/dist/index.min.js\")\n\nmodule.exports = function (player) {\n  /**\n  * Connect a player to a midi input\n  *\n  * The options accepts:\n  *\n  * - channel: the channel to listen to. Listen to all channels by default.\n  *\n  * @param {MIDIInput} input\n  * @param {Object} options - (Optional)\n  * @return {SamplePlayer} the player\n  * @example\n  * var piano = player(...)\n  * window.navigator.requestMIDIAccess().then(function (midiAccess) {\n  *   midiAccess.inputs.forEach(function (midiInput) {\n  *     piano.listenToMidi(midiInput)\n  *   })\n  * })\n  */\n  player.listenToMidi = function (input, options) {\n    var started = {}\n    var opts = options || {}\n    var gain = opts.gain || function (vel) { return vel / 127 }\n\n    input.onmidimessage = function (msg) {\n      var mm = msg.messageType ? msg : midimessage(msg)\n      if (mm.messageType === 'noteon' && mm.velocity === 0) {\n        mm.messageType = 'noteoff'\n      }\n      if (opts.channel && mm.channel !== opts.channel) return\n\n      switch (mm.messageType) {\n        case 'noteon':\n          started[mm.key] = player.play(mm.key, 0, { gain: gain(mm.velocity) })\n          break\n        case 'noteoff':\n          if (started[mm.key]) {\n            started[mm.key].stop()\n            delete started[mm.key]\n          }\n          break\n      }\n    }\n    return player\n  }\n  return player\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/sample-player/lib/midi.js?");

/***/ }),

/***/ "./node_modules/sample-player/lib/notes.js":
/*!*************************************************!*\
  !*** ./node_modules/sample-player/lib/notes.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar note = __webpack_require__(/*! note-parser */ \"./node_modules/sample-player/node_modules/note-parser/index.js\")\nvar isMidi = function (n) { return n !== null && n !== [] && n >= 0 && n < 129 }\nvar toMidi = function (n) { return isMidi(n) ? +n : note.midi(n) }\n\n// Adds note name to midi conversion\nmodule.exports = function (player) {\n  if (player.buffers) {\n    var map = player.opts.map\n    var toKey = typeof map === 'function' ? map : toMidi\n    var mapper = function (name) {\n      return name ? toKey(name) || name : null\n    }\n\n    player.buffers = mapBuffers(player.buffers, mapper)\n    var start = player.start\n    player.start = function (name, when, options) {\n      var key = mapper(name)\n      var dec = key % 1\n      if (dec) {\n        key = Math.floor(key)\n        options = Object.assign(options || {}, { cents: Math.floor(dec * 100) })\n      }\n      return start(key, when, options)\n    }\n  }\n  return player\n}\n\nfunction mapBuffers (buffers, toKey) {\n  return Object.keys(buffers).reduce(function (mapped, name) {\n    mapped[toKey(name)] = buffers[name]\n    return mapped\n  }, {})\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/sample-player/lib/notes.js?");

/***/ }),

/***/ "./node_modules/sample-player/lib/player.js":
/*!**************************************************!*\
  !*** ./node_modules/sample-player/lib/player.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* global AudioBuffer */\n\n\nvar ADSR = __webpack_require__(/*! adsr */ \"./node_modules/adsr/index.js\")\n\nvar EMPTY = {}\nvar DEFAULTS = {\n  gain: 1,\n  attack: 0.01,\n  decay: 0.1,\n  sustain: 0.9,\n  release: 0.3,\n  loop: false,\n  cents: 0,\n  loopStart: 0,\n  loopEnd: 0\n}\n\n/**\n * Create a sample player.\n *\n * @param {AudioContext} ac - the audio context\n * @param {ArrayBuffer|Object<String,ArrayBuffer>} source\n * @param {Onject} options - (Optional) an options object\n * @return {player} the player\n * @example\n * var SamplePlayer = require('sample-player')\n * var ac = new AudioContext()\n * var snare = SamplePlayer(ac, <AudioBuffer>)\n * snare.play()\n */\nfunction SamplePlayer (ac, source, options) {\n  var connected = false\n  var nextId = 0\n  var tracked = {}\n  var out = ac.createGain()\n  out.gain.value = 1\n\n  var opts = Object.assign({}, DEFAULTS, options)\n\n  /**\n   * @namespace\n   */\n  var player = { context: ac, out: out, opts: opts }\n  if (source instanceof AudioBuffer) player.buffer = source\n  else player.buffers = source\n\n  /**\n   * Start a sample buffer.\n   *\n   * The returned object has a function `stop(when)` to stop the sound.\n   *\n   * @param {String} name - the name of the buffer. If the source of the\n   * SamplePlayer is one sample buffer, this parameter is not required\n   * @param {Float} when - (Optional) when to start (current time if by default)\n   * @param {Object} options - additional sample playing options\n   * @return {AudioNode} an audio node with a `stop` function\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   * sample.start()\n   * sample.start(5, { gain: 0.7 }) // name not required since is only one AudioBuffer\n   * @example\n   * var drums = player(ac, { snare: <AudioBuffer>, kick: <AudioBuffer>, ... }).connect(ac.destination)\n   * drums.start('snare')\n   * drums.start('snare', 0, { gain: 0.3 })\n   */\n  player.start = function (name, when, options) {\n    // if only one buffer, reorder arguments\n    if (player.buffer && name !== null) return player.start(null, name, when)\n\n    var buffer = name ? player.buffers[name] : player.buffer\n    if (!buffer) {\n      console.warn('Buffer ' + name + ' not found.')\n      return\n    } else if (!connected) {\n      console.warn('SamplePlayer not connected to any node.')\n      return\n    }\n\n    var opts = options || EMPTY\n    when = Math.max(ac.currentTime, when || 0)\n    player.emit('start', when, name, opts)\n    var node = createNode(name, buffer, opts)\n    node.id = track(name, node)\n    node.env.start(when)\n    node.source.start(when)\n    player.emit('started', when, node.id, node)\n    if (opts.duration) node.stop(when + opts.duration)\n    return node\n  }\n\n  // NOTE: start will be override so we can't copy the function reference\n  // this is obviously not a good design, so this code will be gone soon.\n  /**\n   * An alias for `player.start`\n   * @see player.start\n   * @since 0.3.0\n   */\n  player.play = function (name, when, options) {\n    return player.start(name, when, options)\n  }\n\n  /**\n   * Stop some or all samples\n   *\n   * @param {Float} when - (Optional) an absolute time in seconds (or currentTime\n   * if not specified)\n   * @param {Array} nodes - (Optional) an array of nodes or nodes ids to stop\n   * @return {Array} an array of ids of the stoped samples\n   *\n   * @example\n   * var longSound = player(ac, <AudioBuffer>).connect(ac.destination)\n   * longSound.start(ac.currentTime)\n   * longSound.start(ac.currentTime + 1)\n   * longSound.start(ac.currentTime + 2)\n   * longSound.stop(ac.currentTime + 3) // stop the three sounds\n   */\n  player.stop = function (when, ids) {\n    var node\n    ids = ids || Object.keys(tracked)\n    return ids.map(function (id) {\n      node = tracked[id]\n      if (!node) return null\n      node.stop(when)\n      return node.id\n    })\n  }\n  /**\n   * Connect the player to a destination node\n   *\n   * @param {AudioNode} destination - the destination node\n   * @return {AudioPlayer} the player\n   * @chainable\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   */\n  player.connect = function (dest) {\n    connected = true\n    out.connect(dest)\n    return player\n  }\n\n  player.emit = function (event, when, obj, opts) {\n    if (player.onevent) player.onevent(event, when, obj, opts)\n    var fn = player['on' + event]\n    if (fn) fn(when, obj, opts)\n  }\n\n  return player\n\n  // =============== PRIVATE FUNCTIONS ============== //\n\n  function track (name, node) {\n    node.id = nextId++\n    tracked[node.id] = node\n    node.source.onended = function () {\n      var now = ac.currentTime\n      node.source.disconnect()\n      node.env.disconnect()\n      node.disconnect()\n      player.emit('ended', now, node.id, node)\n    }\n    return node.id\n  }\n\n  function createNode (name, buffer, options) {\n    var node = ac.createGain()\n    node.gain.value = 0 // the envelope will control the gain\n    node.connect(out)\n\n    node.env = envelope(ac, options, opts)\n    node.env.connect(node.gain)\n\n    node.source = ac.createBufferSource()\n    node.source.buffer = buffer\n    node.source.connect(node)\n    node.source.loop = options.loop || opts.loop\n    node.source.playbackRate.value = centsToRate(options.cents || opts.cents)\n    node.source.loopStart = options.loopStart || opts.loopStart\n    node.source.loopEnd = options.loopEnd || opts.loopEnd\n    node.stop = function (when) {\n      var time = when || ac.currentTime\n      player.emit('stop', time, name)\n      var stopAt = node.env.stop(time)\n      node.source.stop(stopAt)\n    }\n    return node\n  }\n}\n\nfunction isNum (x) { return typeof x === 'number' }\nvar PARAMS = ['attack', 'decay', 'sustain', 'release']\nfunction envelope (ac, options, opts) {\n  var env = ADSR(ac)\n  var adsr = options.adsr || opts.adsr\n  PARAMS.forEach(function (name, i) {\n    if (adsr) env[name] = adsr[i]\n    else env[name] = options[name] || opts[name]\n  })\n  env.value.value = isNum(options.gain) ? options.gain\n    : isNum(opts.gain) ? opts.gain : 1\n  return env\n}\n\n/*\n * Get playback rate for a given pitch change (in cents)\n * Basic [math](http://www.birdsoft.demon.co.uk/music/samplert.htm):\n * f2 = f1 * 2^( C / 1200 )\n */\nfunction centsToRate (cents) { return cents ? Math.pow(2, cents / 1200) : 1 }\n\nmodule.exports = SamplePlayer\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/sample-player/lib/player.js?");

/***/ }),

/***/ "./node_modules/sample-player/lib/scheduler.js":
/*!*****************************************************!*\
  !*** ./node_modules/sample-player/lib/scheduler.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar isArr = Array.isArray\nvar isObj = function (o) { return o && typeof o === 'object' }\nvar OPTS = {}\n\nmodule.exports = function (player) {\n  /**\n   * Schedule a list of events to be played at specific time.\n   *\n   * It supports three formats of events for the events list:\n   *\n   * - An array with [time, note]\n   * - An array with [time, object]\n   * - An object with { time: ?, [name|note|midi|key]: ? }\n   *\n   * @param {Float} time - an absolute time to start (or AudioContext's\n   * currentTime if provided number is 0)\n   * @param {Array} events - the events list.\n   * @return {Array} an array of ids\n   *\n   * @example\n   * // Event format: [time, note]\n   * var piano = player(ac, ...).connect(ac.destination)\n   * piano.schedule(0, [ [0, 'C2'], [0.5, 'C3'], [1, 'C4'] ])\n   *\n   * @example\n   * // Event format: an object { time: ?, name: ? }\n   * var drums = player(ac, ...).connect(ac.destination)\n   * drums.schedule(0, [\n   *   { name: 'kick', time: 0 },\n   *   { name: 'snare', time: 0.5 },\n   *   { name: 'kick', time: 1 },\n   *   { name: 'snare', time: 1.5 }\n   * ])\n   */\n  player.schedule = function (time, events) {\n    var now = player.context.currentTime\n    var when = time < now ? now : time\n    player.emit('schedule', when, events)\n    var t, o, note, opts\n    return events.map(function (event) {\n      if (!event) return null\n      else if (isArr(event)) {\n        t = event[0]; o = event[1]\n      } else {\n        t = event.time; o = event\n      }\n\n      if (isObj(o)) {\n        note = o.name || o.key || o.note || o.midi || null\n        opts = o\n      } else {\n        note = o\n        opts = OPTS\n      }\n\n      return player.start(note, when + (t || 0), opts)\n    })\n  }\n  return player\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/sample-player/lib/scheduler.js?");

/***/ }),

/***/ "./node_modules/sample-player/node_modules/note-parser/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sample-player/node_modules/note-parser/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nfunction regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true if the note is the tonic of something.\n * If true, en extra tonicOf property is returned. It's false by default.\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... It can have negative values: -1 = Cb.\n * Can detect pitch class enhramonics.\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nfunction parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || !isTonic && m[4]) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  p.chroma = SEMITONES[p.step] + p.alt\n  if (m[3]) {\n    p.oct = +m[3]\n    p.midi = p.chroma + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\n/**\n * Given a midi number, return its frequency\n * @param {Integer} midi - midi note number\n * @param {Float} tuning - (Optional) the A4 tuning (440Hz by default)\n * @return {Float} frequency in hertzs\n */\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar parser = { parse: parse, regex: regex, midiToFreq: midiToFreq }\nvar FNS = ['letter', 'acc', 'pc', 'step', 'alt', 'chroma', 'oct', 'midi', 'freq']\nFNS.forEach(function (name) {\n  parser[name] = function (src) {\n    var p = parse(src)\n    return p && (typeof p[name] !== 'undefined') ? p[name] : null\n  }\n})\n\nmodule.exports = parser\n\n// extra API docs\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String} note - the note name\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n */\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n */\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/sample-player/node_modules/note-parser/index.js?");

/***/ }),

/***/ "./node_modules/soundfont-player/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/soundfont-player/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar load = __webpack_require__(/*! audio-loader */ \"./node_modules/audio-loader/lib/index.js\")\nvar player = __webpack_require__(/*! sample-player */ \"./node_modules/sample-player/lib/index.js\")\n\n/**\n * Load a soundfont instrument. It returns a promise that resolves to a\n * instrument object.\n *\n * The instrument object returned by the promise has the following properties:\n *\n * - name: the instrument name\n * - play: A function to play notes from the buffer with the signature\n * `play(note, time, duration, options)`\n *\n *\n * The valid options are:\n *\n * - `format`: the soundfont format. 'mp3' by default. Can be 'ogg'\n * - `soundfont`: the soundfont name. 'MusyngKite' by default. Can be 'FluidR3_GM'\n * - `nameToUrl` <Function>: a function to convert from instrument names to URL\n * - `destination`: by default Soundfont uses the `audioContext.destination` but you can override it.\n * - `gain`: the gain of the player (1 by default)\n * - `notes`: an array of the notes to decode. It can be an array of strings\n * with note names or an array of numbers with midi note numbers. This is a\n * performance option: since decoding mp3 is a cpu intensive process, you can limit\n * limit the number of notes you want and reduce the time to load the instrument.\n *\n * @param {AudioContext} ac - the audio context\n * @param {String} name - the instrument name. For example: 'acoustic_grand_piano'\n * @param {Object} options - (Optional) the same options as Soundfont.loadBuffers\n * @return {Promise}\n *\n * @example\n * var Soundfont = require('sounfont-player')\n * Soundfont.instrument('marimba').then(function (marimba) {\n *   marimba.play('C4')\n * })\n */\nfunction instrument (ac, name, options) {\n  if (arguments.length === 1) return function (n, o) { return instrument(ac, n, o) }\n  var opts = options || {}\n  var isUrl = opts.isSoundfontURL || isSoundfontURL\n  var toUrl = opts.nameToUrl || nameToUrl\n  var url = isUrl(name) ? name : toUrl(name, opts.soundfont, opts.format)\n\n  return load(ac, url, { only: opts.only || opts.notes }).then(function (buffers) {\n    var p = player(ac, buffers, opts).connect(opts.destination ? opts.destination : ac.destination)\n    p.url = url\n    p.name = name\n    return p\n  })\n}\n\nfunction isSoundfontURL (name) {\n  return /\\.js(\\?.*)?$/i.test(name)\n}\n\n/**\n * Given an instrument name returns a URL to to the Benjamin Gleitzman's\n * package of [pre-rendered sound fonts](https://github.com/gleitz/midi-js-soundfonts)\n *\n * @param {String} name - instrument name\n * @param {String} soundfont - (Optional) the soundfont name. One of 'FluidR3_GM'\n * or 'MusyngKite' ('MusyngKite' by default)\n * @param {String} format - (Optional) Can be 'mp3' or 'ogg' (mp3 by default)\n * @returns {String} the Soundfont file url\n * @example\n * var Soundfont = require('soundfont-player')\n * Soundfont.nameToUrl('marimba', 'mp3')\n */\nfunction nameToUrl (name, sf, format) {\n  format = format === 'ogg' ? format : 'mp3'\n  sf = sf === 'FluidR3_GM' ? sf : 'MusyngKite'\n  return 'https://gleitz.github.io/midi-js-soundfonts/' + sf + '/' + name + '-' + format + '.js'\n}\n\n// In the 1.0.0 release it will be:\n// var Soundfont = {}\nvar Soundfont = __webpack_require__(/*! ./legacy */ \"./node_modules/soundfont-player/lib/legacy.js\")\nSoundfont.instrument = instrument\nSoundfont.nameToUrl = nameToUrl\n\nif ( true && module.exports) module.exports = Soundfont\nif (typeof window !== 'undefined') window.Soundfont = Soundfont\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/soundfont-player/lib/index.js?");

/***/ }),

/***/ "./node_modules/soundfont-player/lib/legacy.js":
/*!*****************************************************!*\
  !*** ./node_modules/soundfont-player/lib/legacy.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar parser = __webpack_require__(/*! note-parser */ \"./node_modules/note-parser/index.js\")\n\n/**\n * Create a Soundfont object\n *\n * @param {AudioContext} context - the [audio context](https://developer.mozilla.org/en/docs/Web/API/AudioContext)\n * @param {Function} nameToUrl - (Optional) a function that maps the sound font name to the url\n * @return {Soundfont} a soundfont object\n */\nfunction Soundfont (ctx, nameToUrl) {\n  console.warn('new Soundfont() is deprected')\n  console.log('Please use Soundfont.instrument() instead of new Soundfont().instrument()')\n  if (!(this instanceof Soundfont)) return new Soundfont(ctx)\n\n  this.nameToUrl = nameToUrl || Soundfont.nameToUrl\n  this.ctx = ctx\n  this.instruments = {}\n  this.promises = []\n}\n\nSoundfont.prototype.onready = function (callback) {\n  console.warn('deprecated API')\n  console.log('Please use Promise.all(Soundfont.instrument(), Soundfont.instrument()).then() instead of new Soundfont().onready()')\n  Promise.all(this.promises).then(callback)\n}\n\nSoundfont.prototype.instrument = function (name, options) {\n  console.warn('new Soundfont().instrument() is deprecated.')\n  console.log('Please use Soundfont.instrument() instead.')\n  var ctx = this.ctx\n  name = name || 'default'\n  if (name in this.instruments) return this.instruments[name]\n  var inst = {name: name, play: oscillatorPlayer(ctx, options)}\n  this.instruments[name] = inst\n  if (name !== 'default') {\n    var promise = Soundfont.instrument(ctx, name, options).then(function (instrument) {\n      inst.play = instrument.play\n      return inst\n    })\n    this.promises.push(promise)\n    inst.onready = function (cb) {\n      console.warn('onready is deprecated. Use Soundfont.instrument().then()')\n      promise.then(cb)\n    }\n  } else {\n    inst.onready = function (cb) {\n      console.warn('onready is deprecated. Use Soundfont.instrument().then()')\n      cb()\n    }\n  }\n  return inst\n}\n\n/*\n * Load the buffers of a given instrument name. It returns a promise that resolves\n * to a hash with midi note numbers as keys, and audio buffers as values.\n *\n * @param {AudioContext} ac - the audio context\n * @param {String} name - the instrument name (it accepts an url if starts with \"http\")\n * @param {Object} options - (Optional) options object\n * @return {Promise} a promise that resolves to a Hash of { midiNoteNum: <AudioBuffer> }\n *\n * The options object accepts the following keys:\n *\n * - nameToUrl {Function}: a function to convert from instrument names to urls.\n * By default it uses Benjamin Gleitzman's package of\n * [pre-rendered sound fonts](https://github.com/gleitz/midi-js-soundfonts)\n * - notes {Array}: the list of note names to be decoded (all by default)\n *\n * @example\n * var Soundfont = require('soundfont-player')\n * Soundfont.loadBuffers(ctx, 'acoustic_grand_piano').then(function(buffers) {\n *  buffers[60] // => An <AudioBuffer> corresponding to note C4\n * })\n */\nfunction loadBuffers (ac, name, options) {\n  console.warn('Soundfont.loadBuffers is deprecate.')\n  console.log('Use Soundfont.instrument(..) and get buffers properties from the result.')\n  return Soundfont.instrument(ac, name, options).then(function (inst) {\n    return inst.buffers\n  })\n}\nSoundfont.loadBuffers = loadBuffers\n\n/**\n * Returns a function that plays an oscillator\n *\n * @param {AudioContext} ac - the audio context\n * @param {Hash} defaultOptions - (Optional) a hash of options:\n * - vcoType: the oscillator type (default: 'sine')\n * - gain: the output gain value (default: 0.4)\n  * - destination: the player destination (default: ac.destination)\n */\nfunction oscillatorPlayer (ctx, defaultOptions) {\n  defaultOptions = defaultOptions || {}\n  return function (note, time, duration, options) {\n    console.warn('The oscillator player is deprecated.')\n    console.log('Starting with version 0.9.0 you will have to wait until the soundfont is loaded to play sounds.')\n    var midi = note > 0 && note < 129 ? +note : parser.midi(note)\n    var freq = midi ? parser.midiToFreq(midi, 440) : null\n    if (!freq) return\n\n    duration = duration || 0.2\n\n    options = options || {}\n    var destination = options.destination || defaultOptions.destination || ctx.destination\n    var vcoType = options.vcoType || defaultOptions.vcoType || 'sine'\n    var gain = options.gain || defaultOptions.gain || 0.4\n\n    var vco = ctx.createOscillator()\n    vco.type = vcoType\n    vco.frequency.value = freq\n\n    /* VCA */\n    var vca = ctx.createGain()\n    vca.gain.value = gain\n\n    /* Connections */\n    vco.connect(vca)\n    vca.connect(destination)\n\n    vco.start(time)\n    if (duration > 0) vco.stop(time + duration)\n    return vco\n  }\n}\n\n/**\n * Given a note name, return the note midi number\n *\n * @name noteToMidi\n * @function\n * @param {String} noteName\n * @return {Integer} the note midi number or null if not a valid note name\n */\nSoundfont.noteToMidi = parser.midi\n\nmodule.exports = Soundfont\n\n\n//# sourceURL=webpack://soundfont-wam/./node_modules/soundfont-player/lib/legacy.js?");

/***/ }),

/***/ "../shared/getBaseUrl.tsx":
/*!********************************!*\
  !*** ../shared/getBaseUrl.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getBaseUrl\": () => (/* binding */ getBaseUrl)\n/* harmony export */ });\nconst getBaseUrl = (relativeURL) => {\n    const baseURL = relativeURL.href.substring(0, relativeURL.href.lastIndexOf('/'));\n    return baseURL;\n};\n\n\n//# sourceURL=webpack://soundfont-wam/../shared/getBaseUrl.tsx?");

/***/ }),

/***/ "../shared/insertStyle.ts":
/*!********************************!*\
  !*** ../shared/insertStyle.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"insertStyle\": () => (/* binding */ insertStyle)\n/* harmony export */ });\nfunction insertStyle(shadow, style) {\n    const el = document.createElement('style');\n    el.textContent = style;\n    shadow.appendChild(el);\n}\n\n\n//# sourceURL=webpack://soundfont-wam/../shared/insertStyle.ts?");

/***/ }),

/***/ "../shared/midi.ts":
/*!*************************!*\
  !*** ../shared/midi.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MIDI\": () => (/* binding */ MIDI)\n/* harmony export */ });\nclass MIDI {\n}\nMIDI.NOTE_ON = 0x90;\nMIDI.NOTE_OFF = 0x80;\nMIDI.CC = 0xB0;\n\n\n//# sourceURL=webpack://soundfont-wam/../shared/midi.ts?");

/***/ }),

/***/ "../shared/ui/Select.tsx":
/*!*******************************!*\
  !*** ../shared/ui/Select.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Select\": () => (/* binding */ Select)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"../../../node_modules/preact/dist/preact.module.js\");\n\nclass Select extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super();\n        this.lastRenderedValue = \"-1\";\n        this.animationFrame = this.animationFrame.bind(this);\n        this.scheduleFrame = this.scheduleFrame.bind(this);\n        this.scheduleAnimation = this.scheduleAnimation.bind(this);\n    }\n    onChange(e) {\n        if (this.props.onChange) {\n            this.props.onChange(e.target.value);\n        }\n    }\n    cancelAnimation() {\n        if (this.animationTimeout != undefined) {\n            window.clearTimeout(this.animationTimeout);\n            this.animationTimeout = undefined;\n        }\n        if (this.animationRequest != undefined) {\n            window.cancelAnimationFrame(this.animationRequest);\n            this.animationRequest = undefined;\n        }\n    }\n    scheduleAnimation() {\n        this.animationTimeout = window.setTimeout(this.scheduleFrame, 100);\n    }\n    scheduleFrame() {\n        this.animationRequest = window.requestAnimationFrame(this.animationFrame);\n    }\n    componentWillUnmount() {\n        this.cancelAnimation();\n    }\n    animationFrame() {\n        let newValue = this.props.value();\n        if (this.lastRenderedValue == newValue) {\n            this.scheduleAnimation();\n            return;\n        }\n        this.lastRenderedValue = newValue;\n        for (let option of this.select.options) {\n            option.selected = (option.value == newValue);\n        }\n        this.scheduleAnimation();\n    }\n    setup(ref) {\n        if (ref == null) {\n            return;\n        }\n        if (ref == this.ref && this.sameArray(this.props.options, this.renderedOptions) && this.sameArray(this.props.values, this.renderedValues)) {\n            return;\n        }\n        this.ref = ref;\n        ref.innerHTML = \"\";\n        if (this.props.value === undefined || this.props.value === null) {\n            throw `Select with label ${this.props.label} values ${this.props.values} has null value`;\n        }\n        if (!this.select) {\n            this.select = document.createElement(\"select\");\n            this.select.addEventListener(\"change\", e => this.onChange(e));\n        }\n        else {\n            while (this.select.firstChild) {\n                this.select.removeChild(this.select.firstChild);\n            }\n            try {\n                this.ref.removeChild(this.select);\n            }\n            catch (e) {\n            }\n        }\n        this.ref.appendChild(this.select);\n        this.props.options.forEach((name, index) => {\n            let option = document.createElement(\"option\");\n            option.text = name;\n            option.value = (this.props.values) ? this.props.values[index].toString() : index.toString();\n            this.select.appendChild(option);\n        });\n        this.lastRenderedValue = \"-1\";\n        this.renderedOptions = this.props.options;\n        this.renderedValues = this.props.values;\n        this.cancelAnimation();\n        this.animationFrame();\n    }\n    render() {\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {});\n        let style = this.props.style ? this.props.style : \"\";\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: \"ComponentWrapper\", style: style },\n            this.props.label && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\", null, this.props.label),\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { ref: (e) => this.setup(e), style: \"color: black;\", class: \"ComponentSelect\" }));\n    }\n    sameArray(lhs, rhs) {\n        if (lhs === undefined && rhs === undefined) {\n            return true;\n        }\n        if (lhs === undefined || rhs === undefined) {\n            return false;\n        }\n        return (lhs.length == rhs.length && lhs.every((l, i) => l == rhs[i]));\n    }\n}\n\n\n//# sourceURL=webpack://soundfont-wam/../shared/ui/Select.tsx?");

/***/ }),

/***/ "./src/Node.ts":
/*!*********************!*\
  !*** ./src/Node.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SoundfontPlayerNode)\n/* harmony export */ });\n/* harmony import */ var _webaudiomodules_sdk_parammgr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @webaudiomodules/sdk-parammgr */ \"../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js\");\n/* harmony import */ var _shared_midi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/midi */ \"../shared/midi.ts\");\n/* harmony import */ var soundfont_player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! soundfont-player */ \"./node_modules/soundfont-player/lib/index.js\");\n/* harmony import */ var soundfont_player__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(soundfont_player__WEBPACK_IMPORTED_MODULE_2__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass SoundfontPlayerNode extends _webaudiomodules_sdk_parammgr__WEBPACK_IMPORTED_MODULE_0__.CompositeAudioNode {\n    constructor(audioContext, options = {}) {\n        super(audioContext, options);\n        this._wamNode = undefined;\n        this.instrument = \"acoustic_grand_piano\";\n        this.loadedInstrument = \"\";\n        this.loadingInstrument = \"\";\n        this.isEnabled = true;\n        console.log(\"Soundfont-player constructor()\");\n        this.heldNotes = [];\n        this.heldNotes.fill(undefined, 0, 128);\n        this.createNodes();\n    }\n    get paramMgr() {\n        return this._wamNode;\n    }\n    setup(paramMgr) {\n        paramMgr.addEventListener('wam-midi', (e) => this.processMIDIEvents([{ event: e.detail.data.bytes, time: 0 }]));\n        this._wamNode = paramMgr;\n    }\n    set status(_sig) {\n        this.isEnabled = _sig;\n    }\n    createNodes() {\n        this._output = this.context.createGain();\n        this.updateFromState();\n    }\n    processMIDIEvents(midiEvents) {\n        midiEvents.forEach(message => {\n            if (message.event[0] == _shared_midi__WEBPACK_IMPORTED_MODULE_1__.MIDI.NOTE_ON && message.event[2] > 0) {\n                let midiNote = message.event[1];\n                this.noteOn(midiNote, message.time);\n            }\n            else if (message.event[0] == _shared_midi__WEBPACK_IMPORTED_MODULE_1__.MIDI.NOTE_OFF || (message.event[0] == _shared_midi__WEBPACK_IMPORTED_MODULE_1__.MIDI.NOTE_ON && message.event[2] == 0)) {\n                let midiNote = message.event[1];\n                this.noteOff(midiNote, message.time);\n            }\n        });\n    }\n    noteOn(note, time) {\n        if (this.soundfont) {\n            if (this.heldNotes[note]) {\n                this.heldNotes[note].stop();\n            }\n            this.heldNotes[note] = this.soundfont.play(note, time);\n        }\n    }\n    noteOff(note, time) {\n        if (this.soundfont && this.heldNotes[note]) {\n            this.heldNotes[note].stop(time);\n            this.heldNotes[note] = undefined;\n        }\n    }\n    updateFromState() {\n        let instrument = this.instrument;\n        if (this.loadedInstrument != instrument) {\n            if (instrument != this.loadingInstrument) {\n                this.loadingInstrument = instrument;\n                soundfont_player__WEBPACK_IMPORTED_MODULE_2___default().instrument(this.context, instrument, { destination: this._output }).then((sf) => {\n                    this.soundfont = sf;\n                    this.loadedInstrument = instrument;\n                });\n            }\n        }\n    }\n    setState(state) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (state && state.instrument) {\n                this.instrument = state.instrument;\n                this.updateFromState();\n            }\n        });\n    }\n    getState() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                instrument: this.instrument\n            };\n        });\n    }\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./src/Node.ts?");

/***/ }),

/***/ "./src/SoundfontView.tsx":
/*!*******************************!*\
  !*** ./src/SoundfontView.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundfontView\": () => (/* binding */ SoundfontView)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _shared_ui_Select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/ui/Select */ \"../shared/ui/Select.tsx\");\n/* harmony import */ var _SoundfontView_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SoundfontView.scss */ \"./src/SoundfontView.scss\");\n\n\n\nlet styles = _SoundfontView_scss__WEBPACK_IMPORTED_MODULE_2__.default.locals;\nlet availableInstruments = [\"accordion\",\n    \"acoustic_bass\",\n    \"acoustic_grand_piano\",\n    \"acoustic_guitar_nylon\",\n    \"acoustic_guitar_steel\",\n    \"agogo\",\n    \"alto_sax\",\n    \"applause\",\n    \"bagpipe\",\n    \"banjo\",\n    \"baritone_sax\",\n    \"bassoon\",\n    \"bird_tweet\",\n    \"blown_bottle\",\n    \"brass_section\",\n    \"breath_noise\",\n    \"bright_acoustic_piano\",\n    \"celesta\",\n    \"cello\",\n    \"choir_aahs\",\n    \"church_organ\",\n    \"clarinet\",\n    \"clavinet\",\n    \"contrabass\",\n    \"distortion_guitar\",\n    \"drawbar_organ\",\n    \"dulcimer\",\n    \"electric_bass_finger\",\n    \"electric_bass_pick\",\n    \"electric_grand_piano\",\n    \"electric_guitar_clean\",\n    \"electric_guitar_jazz\",\n    \"electric_guitar_muted\",\n    \"electric_piano_1\",\n    \"electric_piano_2\",\n    \"english_horn\",\n    \"fiddle\",\n    \"flute\",\n    \"french_horn\",\n    \"fretless_bass\",\n    \"fx_1_rain\",\n    \"fx_2_soundtrack\",\n    \"fx_3_crystal\",\n    \"fx_4_atmosphere\",\n    \"fx_5_brightness\",\n    \"fx_6_goblins\",\n    \"fx_7_echoes\",\n    \"fx_8_scifi\",\n    \"glockenspiel\",\n    \"guitar_fret_noise\",\n    \"guitar_harmonics\",\n    \"gunshot\",\n    \"harmonica\",\n    \"harpsichord\",\n    \"helicopter\",\n    \"honkytonk_piano\",\n    \"kalimba\",\n    \"koto\",\n    \"lead_1_square\",\n    \"lead_2_sawtooth\",\n    \"lead_3_calliope\",\n    \"lead_4_chiff\",\n    \"lead_5_charang\",\n    \"lead_6_voice\",\n    \"lead_7_fifths\",\n    \"lead_8_bass__lead\",\n    \"marimba\",\n    \"melodic_tom\",\n    \"music_box\",\n    \"muted_trumpet\",\n    \"oboe\",\n    \"ocarina\",\n    \"orchestra_hit\",\n    \"orchestral_harp\",\n    \"overdriven_guitar\",\n    \"pad_1_new_age\",\n    \"pad_2_warm\",\n    \"pad_3_polysynth\",\n    \"pad_4_choir\",\n    \"pad_5_bowed\",\n    \"pad_6_metallic\",\n    \"pad_7_halo\",\n    \"pad_8_sweep\",\n    \"pan_flute\",\n    \"percussive_organ\",\n    \"percussion\",\n    \"piccolo\",\n    \"pizzicato_strings\",\n    \"recorder\",\n    \"reed_organ\",\n    \"reverse_cymbal\",\n    \"rock_organ\",\n    \"seashore\",\n    \"shakuhachi\",\n    \"shamisen\",\n    \"shanai\",\n    \"sitar\",\n    \"slap_bass_1\",\n    \"slap_bass_2\",\n    \"soprano_sax\",\n    \"steel_drums\",\n    \"string_ensemble_1\",\n    \"string_ensemble_2\",\n    \"synth_bass_1\",\n    \"synth_bass_2\",\n    \"synth_brass_1\",\n    \"synth_brass_2\",\n    \"synth_choir\",\n    \"synth_drum\",\n    \"synth_strings_1\",\n    \"synth_strings_2\",\n    \"taiko_drum\",\n    \"tango_accordion\",\n    \"telephone_ring\",\n    \"tenor_sax\",\n    \"timpani\",\n    \"tinkle_bell\",\n    \"tremolo_strings\",\n    \"trombone\",\n    \"trumpet\",\n    \"tuba\",\n    \"tubular_bells\",\n    \"vibraphone\",\n    \"viola\",\n    \"violin\",\n    \"voice_oohs\",\n    \"whistle\",\n    \"woodblock\",\n    \"xylophone\"\n];\nclass SoundfontView extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super();\n    }\n    componentDidMount() {\n    }\n    componentWillUnmount() {\n    }\n    paramChanged(param, value) {\n        this.props.plugin.audioNode.paramMgr.setParamValue(param, value);\n    }\n    instrumentChanged(v) {\n        this.props.plugin.synth.setState({ instrument: v });\n    }\n    render() {\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {});\n        let params = this.props.plugin.audioNode.paramMgr;\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.module },\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { style: styles.section },\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Select__WEBPACK_IMPORTED_MODULE_1__.Select, { label: \"Instrument\", options: availableInstruments, values: availableInstruments, value: () => this.props.plugin.synth.instrument, onChange: (v) => this.instrumentChanged(v) }),\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { style: \"flex: 1\" }))));\n    }\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./src/SoundfontView.tsx?");

/***/ }),

/***/ "./src/index.tsx":
/*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SoundfontModule)\n/* harmony export */ });\n/* harmony import */ var _webaudiomodules_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @webaudiomodules/sdk */ \"../../../node_modules/@webaudiomodules/sdk/dist/index.js\");\n/* harmony import */ var _webaudiomodules_sdk_parammgr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @webaudiomodules/sdk-parammgr */ \"../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js\");\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Node */ \"./src/Node.ts\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _SoundfontView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SoundfontView */ \"./src/SoundfontView.tsx\");\n/* harmony import */ var _shared_getBaseUrl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/getBaseUrl */ \"../shared/getBaseUrl.tsx\");\n/* harmony import */ var _SoundfontView_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SoundfontView.scss */ \"./src/SoundfontView.scss\");\n/* harmony import */ var _shared_insertStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../shared/insertStyle */ \"../shared/insertStyle.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\nclass SoundfontModule extends _webaudiomodules_sdk__WEBPACK_IMPORTED_MODULE_0__.WebAudioModule {\n    constructor() {\n        super(...arguments);\n        this._baseURL = (0,_shared_getBaseUrl__WEBPACK_IMPORTED_MODULE_5__.getBaseUrl)(new URL('.', __webpack_require__.p));\n        this._descriptorUrl = `${this._baseURL}/descriptor.json`;\n    }\n    _loadDescriptor() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this._descriptorUrl;\n            if (!url)\n                throw new TypeError('Descriptor not found');\n            const response = yield fetch(url);\n            const descriptor = yield response.json();\n            Object.assign(this._descriptor, descriptor);\n            return descriptor;\n        });\n    }\n    initialize(state) {\n        const _super = Object.create(null, {\n            initialize: { get: () => super.initialize }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._loadDescriptor();\n            return _super.initialize.call(this, state);\n        });\n    }\n    createAudioNode(initialState) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const synthNode = new _Node__WEBPACK_IMPORTED_MODULE_2__.default(this.audioContext);\n            this.synth = synthNode;\n            const paramsConfig = {};\n            const internalParamsConfig = {};\n            const paramsMapping = {};\n            const optionsIn = { internalParamsConfig, paramsConfig, paramsMapping };\n            const paramMgrNode = yield _webaudiomodules_sdk_parammgr__WEBPACK_IMPORTED_MODULE_1__.ParamMgrFactory.create(this, optionsIn);\n            synthNode.setup(paramMgrNode);\n            if (initialState)\n                synthNode.setState(initialState);\n            return synthNode;\n        });\n    }\n    createGui() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const div = document.createElement('div');\n            (0,preact__WEBPACK_IMPORTED_MODULE_3__.h)(\"div\", {});\n            div.setAttribute(\"style\", \"height: 100%; width: 100%; display: flex; flex: 1;\");\n            var shadow = div.attachShadow({ mode: 'open' });\n            (0,_shared_insertStyle__WEBPACK_IMPORTED_MODULE_7__.insertStyle)(shadow, _SoundfontView_scss__WEBPACK_IMPORTED_MODULE_6__.default.toString());\n            (0,preact__WEBPACK_IMPORTED_MODULE_3__.render)((0,preact__WEBPACK_IMPORTED_MODULE_3__.h)(_SoundfontView__WEBPACK_IMPORTED_MODULE_4__.SoundfontView, { plugin: this }), shadow);\n            return div;\n        });\n    }\n    destroyGui(el) {\n        (0,preact__WEBPACK_IMPORTED_MODULE_3__.render)(null, el.shadowRoot);\n    }\n}\n\n\n//# sourceURL=webpack://soundfont-wam/./src/index.tsx?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	var scriptUrl;
/******/ 	if (typeof import.meta.url === "string") scriptUrl = import.meta.url
/******/ 	// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 	// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 	if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 	scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 	__webpack_require__.p = scriptUrl;
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.tsx");
/******/ var __webpack_exports__default = __webpack_exports__.default;
/******/ export { __webpack_exports__default as default };
/******/ 
